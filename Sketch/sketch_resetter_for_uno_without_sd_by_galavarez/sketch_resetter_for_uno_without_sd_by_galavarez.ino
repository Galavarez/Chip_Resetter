/* 
Auto Resetter wthiout sd card by Galavarez
* Версия 29.12.2017 
- Переписал код для упрощения добавления новых чипов
- Исправил ошибку в генерации серийного номера
- Исправил некоторые другие ошибки

* Версия 17.12.2017 
- Добавил чип Ricoh SP 210 спасибо за дамп copiermaster

* Версия 25.11.2017 
- Добавил чип Ricoh SP 200, 202, 203 на 2.6К

* Версия 21.11.2017 
- Переписал проверку дампа после заливки его в чип
- Добавил распиновку чипа в правом верхнем углу G - gnd, V - vcc, D - data, C - clock

* Версия 14.11.2017 
- Добавил вывод дампа из чипа на экран по кнопки вниз первых 128 байт

* Версия 03.11.2017 11:17
- Добавил чип Xerox PE 220

* Версия 13.10.2017 14:36
- Добавил проверку на запись дампа в чип 

* Версия 12.10.2017 12:37
- Добавил задержку при подачи питания для стабильности
- Вернул обработку нажатий кнопок для DOWN и SELECT 

* Версия 06.10.2017 19:17
- Добавил чип Ricoh SP 100 (SP 101E)
- Добавил чип Ricoh SP 111 (SP 110E)
- Добавил чип Ricoh SP 150
- Добавил чип Ricoh SP 300
- Добавил чип Ricoh SP 311
- Добавил чип Samsung SCX 4200 (автоматическая смена номера CRUM)
- Добавил чип Xerox WC 3119 (автоматическая смена номера CRUM)
*/

// Подключаем библиотеку которая позволяет управлять микросхемами 24CXX подключать их на ПИН A4 (SDA), A5 (SCL)
#include <Eeprom24C04_16.h> 
// Подключаем библиотеку которая позволяет взаимодействовать с различными устройствами по интерфейсу I2C / TWI.
#include <Wire.h> 
// Подключаем библиотеку которая позволяет управлять различными жидкокристаллическими дисплеями (LCD)
#include <LiquidCrystal.h>  
// Подключаем библиотеку для записи статических строк во FLASH а не в RAM 
// Serial.print(F(Тут_статическая_строка)) или const PROGMEM до вызова SETUP
// Serial.println(pgm_read_byte(&dump_ricoh_sp_150[i]), HEX); чтение переменной без изменений из FLASH
#include <avr/pgmspace.h>

// Пины LCD 1602 (RS, E, D4, D5, D6, D7)
LiquidCrystal lcd( 8, 9, 4, 5, 6, 7 );

// Пин питания у Вас может быть другой
#define POWER_PIN A2
// Пин для работы генератора случайных чисел
#define RANDOM_PIN A3

// Адрес чипа (адрес динамический, меняется от чипа к чипу)
byte address_eeprom;

// Номер чипа
byte global_id = 1;

// Имя дампа
const byte *global_name_dump;

// Размер чипа
int global_size_dump;

// Номер байта конца серийного номера (для смены серийного номера в самсунгах)
int global_number_byte_end_of_sn;

// Состояние кнопки (защита от повторного срабатывания)
boolean global_button_press = false; // true - кнопка нажата

/****************************** ДАМПЫ ЧИПОВ ******************************/

// RICOH SP101E (407059) от Aficio SP 100 (SF/SU/E)
const PROGMEM byte dump_ricoh_aficio_sp_101e_sp_100[128] = {
  0x20, 0x00, 0x01, 0x03, 0x03, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x36, 0x39, 0x34, 0x37, 
  0x12, 0x04, 0x4D, 0x41, 0x16, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//RICOH AFICIO SP 111 SF/SU CARTRIDGE SP 110E
const PROGMEM byte dump_ricoh_aficio_sp_110e_sp_111[128] = {
  0x20, 0x00, 0x01, 0x05, 0x01, 0x01, 0x03, 0x00, 0x64, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x14, 0x05, 0x4D, 0x47, 0x21, 0x00, 0x08, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x64, 0x30, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x82, 0xB9, 0x00, 0x00, 0x64, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// SP150HE (408010) 1.5k от Aficio SP 150 (W/SU/SUW) 24С01
const PROGMEM byte dump_ricoh_aficio_sp_150[128] = {
  0x32, 0x00, 0x01, 0x03, 0x02, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x38, 0x30, 0x31, 0x30, 
  0x16, 0x10, 0x4D, 0x4D, 0x26, 0x00, 0x01, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Ricoh R-SP200HS-2.6K for Ricoh SP 200,202,203
const PROGMEM byte dump_ricoh_sp_200_202_203[256] = {
  0x21, 0x00, 0x01, 0x04, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x34, 0x30, 0x37, 0x32, 0x35, 0x37, 
  0x13, 0x07, 0x4D, 0x43, 0x11, 0x00, 0x22, 0x32, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x01, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// Ricoh Aficio SP 210 (407971) 
const PROGMEM byte dump_ricoh_aficio_sp_210[128] = {
  0x21, 0x00, 0x01, 0x03, 0x01, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x37, 0x39, 0x37, 0x31, 
  0x15, 0x03, 0x4D, 0x50, 0x04, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// SP300 (406956) 1.5k от Aficio SP 300DN 24С01
const PROGMEM byte dump_ricoh_aficio_sp_300[128] = {
  0x13, 0x00, 0x01, 0x03, 0x03, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x36, 0x39, 0x35, 0x36, 
  0x11, 0x11, 0x4A, 0x4D, 0x51, 0x00, 0x19, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// SP 311 (407246) 3.5K 
const PROGMEM byte dump_ricoh_aficio_sp_311[128] = {
  0x07, 0x00, 0x01, 0x03, 0x07, 0x01, 0x01, 0x00, 0x00, 0x00, 0x34, 0x30, 0x37, 0x32, 0x34, 0x36, 
  0x13, 0x00, 0x47, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x58, 0x12, 
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// SCX-4200 3k от Samsung SCX-4200/4220 24С04
const PROGMEM byte dump_samsung_scx_4200[512] = {
  0x43, 0x34, 0x32, 0x30, 0x30, 0x45, 0x58, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x30, 0x36, 0x30, 0x32, 0x00, 0x00, 
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x30, 0x36, 0x30, 0x32, 0x32, 0x31, 0x33, 0x32, 0x36, 0x33, 0x32, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x34, 0x32, 0x30, 0x30, 0x45, 0x58, 0x50, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xDD, 0x00, 0x22, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x43, 0x72, 0x75, 0x6D, 0x20, 0x42, 0x79, 0x20, 
  0x48, 0x77, 0x61, 0x6E, 0x67, 0x2E, 0x73, 0x6B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};


// XEROX WC 3119 24С04
const PROGMEM byte dump_xerox_wc_3119[512] = {
  0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x30, 0x36, 0x30, 0x36, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x30, 0x36, 0x30, 0x36, 0x32, 0x39, 0x30, 0x39, 0x33, 0x31, 0x34, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xDD, 0x00, 0x22, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x43, 0x72, 0x75, 0x6D, 0x20, 0x42, 0x79, 0x20,
  0x48, 0x77, 0x61, 0x6E, 0x67, 0x2E, 0x73, 0x6B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// XEROX PE 220 2k
const PROGMEM byte dump_xerox_pe_220[256] = {
  0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x30, 0x36, 0x30, 0x34, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x30, 0x36, 0x30, 0x34, 0x30, 0x36, 0x33, 0x33, 0x35, 0x38, 0x33, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

/****************************** SETUP ******************************/

void setup() 
{
  lcd.begin(16, 2);  // Инициализируем LCD 16x2
  Serial.begin(9600); //инициализируем последовательное соединение для работы с ПК
  while (!Serial) { ; } // Ждем когда подключится ардуино к пк по usb
  Wire.begin(); //инициализируем библиотеку I2C / TWI для работы с I2C устройствами
 
  // Пин А2 для питания чипа устанавливаем в положение OUTPUT
  // Пин A0-14 A1-15 A2-16 A3-17 A4-18 A5-19
  pinMode(POWER_PIN, OUTPUT);
  
  // Пин А3 для работы генератора случайных чисел
  randomSeed(analogRead(RANDOM_PIN));

  // Показываем первый чип на экране
  database(global_id); 
}

/****************************** LOOP ******************************/

void loop() 
{
  /* ОБРАБОТКА НАЖАТИЯ КНОПОК */

  // Задаем номер порта с которого производим считывание
  int analog_number = analogRead(0); 
  //Serial.println(analog_number);

  if (analog_number < 100 && global_button_press == false) // Если это кнопка Right и другие кнопки не нажаты то
  {
    if (analog_debonce(100) == true) // делаем проверку от дребезга кнопок
    {
       Serial.println(F("CLICK BUTTON RIGHT"));
      // Увеличиваем счетчик
      global_id++;
      
      // Показываем на экране
      database(global_id);
    }
  }
  else if (analog_number < 200 && global_button_press == false) // Если это кнопка UP и другие кнопки не нажаты то
  {
    if (analog_debonce(200) == true) // делаем проверку от дребезга кнопок
    {
       Serial.println(F("CLICK BUTTON UP")); // UPLOAD -- закачиваем дамп
      // Подаем питание и сканируем шину i2c на наличие чипа
      power_on_for_chip();
      
      // Прошивка чипа 
      firmware();
      
      // Выключаем питание
      power_off_for_chip();

      // Возврат в меню
      database(global_id);

      // Тест данных
      //test_chip_on_pc(128);
    }
  }
  else if (analog_number < 400 && global_button_press == false) // Если это кнопка Down и другие кнопки не нажаты то
  {
    if (analog_debonce(400) == true) // делаем проверку от дребезга кнопок
    {
      Serial.println(F("CLICK BUTTON DOWN"));
      // Подаем питание и сканируем шину i2c на наличие чипа
      power_on_for_chip();
      // Считываем чип и показываем его на lcd
      read_chip_and_display_it();
      // Выключаем питание
      power_off_for_chip();
    }
  }
  else if (analog_number < 600 && global_button_press == false) // Если это кнопка Left и другие кнопки не нажаты то
  {
    if (analog_debonce(600) == true) // делаем проверку от дребезга кнопок
    {
      Serial.println(F("CLICK BUTTON LEFT"));
      // Уменьшаем счетчик 
      global_id--; 
      // Показываем на экране
      database(global_id);
    }
  }
  else if (analog_number < 800 && global_button_press == false) // Если это кнопка Select и другие кнопки не нажаты то
  {
    if (analog_debonce(800) == true)  // делаем проверку от дребезга кнопок
    {
      Serial.println(F("CLICK BUTTON SELECT")); 
    }
  }

  // Обнуляем переменную globalBntPress если все кнопки отпущены
  if ( analogRead(0) > 1000)  { global_button_press = false; }
}

/****************************** БАЗА ДАННЫХ ******************************/

void database(byte id)
{
  switch (id)
  {    
    case 1:
      lcd.clear();
      lcd.print(F("RICOH       GVCD"));
      lcd.setCursor(0,1);
      lcd.print(F("SP 100 (SP 101E)"));
      global_name_dump = dump_ricoh_aficio_sp_101e_sp_100; // ссылка на дамп
      global_size_dump = 128; // размер дампа
      global_number_byte_end_of_sn = 0; // младший разряд серийного номера, если 0 то серийного номера нет
      break;
    case 2:
      lcd.clear();
      lcd.print(F("RICOH       GVCD"));
      lcd.setCursor(0,1);
      lcd.print(F("SP 111 (SP 110E)"));
      global_name_dump = dump_ricoh_aficio_sp_110e_sp_111;
      global_size_dump = 128;
      global_number_byte_end_of_sn = 0;
      break;      
    case 3:
      lcd.clear();
      lcd.print(F("RICOH       GVCD"));
      lcd.setCursor(0,1);
      lcd.print(F("SP 150"));
      global_name_dump = dump_ricoh_aficio_sp_150;
      global_size_dump = 128;
      global_number_byte_end_of_sn = 0;
      break;
    case 4:
      lcd.clear();
      lcd.print(F("RICOH       GVCD"));
      lcd.setCursor(0,1);
      lcd.print(F("SP 200 202 203"));
      global_name_dump = dump_ricoh_sp_200_202_203;
      global_size_dump = 256;
      global_number_byte_end_of_sn = 0;
      break;
    case 5:
      lcd.clear();
      lcd.print(F("RICOH       GVCD"));
      lcd.setCursor(0,1);
      lcd.print(F("SP 210"));
      global_name_dump = dump_ricoh_aficio_sp_210;
      global_size_dump = 128;
      global_number_byte_end_of_sn = 0;
      break;  
    case 6:
      lcd.clear();
      lcd.print(F("RICOH       GVDC"));
      lcd.setCursor(0,1);
      lcd.print(F("SP 300"));
      global_name_dump = dump_ricoh_aficio_sp_300;
      global_size_dump = 128;
      global_number_byte_end_of_sn = 0;
      break;    
    case 7:
      lcd.clear();
      lcd.print(F("RICOH       GVCD"));
      lcd.setCursor(0,1);
      lcd.print(F("SP 311"));
      global_name_dump = dump_ricoh_aficio_sp_311;
      global_size_dump = 128;
      global_number_byte_end_of_sn = 0;
      break;
    case 8:
      lcd.clear();
      lcd.print(F("SAMSUNG     VDCG"));
      lcd.setCursor(0,1);
      lcd.print(F("SCX 4200"));
      global_name_dump = dump_samsung_scx_4200;
      global_size_dump = 512;
      global_number_byte_end_of_sn = 63;
      break;
    case 9:
      lcd.clear();
      lcd.print(F("XEROX       VDCG"));
      lcd.setCursor(0,1);
      lcd.print(F("WC 3119"));
      global_name_dump = dump_xerox_wc_3119;
      global_size_dump = 512;
      global_number_byte_end_of_sn = 63;
      break;
    case 10:
      lcd.clear();
      lcd.print(F("XEROX       VDCG"));
      lcd.setCursor(0,1);
      lcd.print(F("PE 220"));
      global_name_dump = dump_xerox_pe_220;
      global_size_dump = 256;
      global_number_byte_end_of_sn = 63;
      break;
    default:
      // Если номера нет в базе то переходим к 1 чипу
      global_id = 1;
      database(global_id);
  }    
}


/****************************** ЗАЩИТА ОТ ДРЕБЕЗГА КНОПОК И ПОВТОРНЫХ НАЖАТИЙ ******************************/

boolean analog_debonce(int max_value)
{
  delay(50); // Пауза перед повторным считыванием кнопки
  if ( analogRead(0) < max_value) // Если все еще держим кнопку а не случайный дребезг то
  {
    global_button_press = true; // Запоминаем что нажали кнопку
    return true; // Проверка на дребегз пройдена
  }
  else
  {
    return false; // Проверка на дребегз НЕ пройдена
  }
}

/****************************** ВКЛЮЧАЕМ ПИТАНИЯ ЧИПА ******************************/

void power_on_for_chip()
{
  digitalWrite(POWER_PIN, HIGH); // Подаем питания на A2 для запитки чипа
  delay(500); // Задержка для поднятия напряжения
  search_address_chip(); // Сканируем шину I2C на наличия чипа и сохраняем адрес его в памяти
}

/****************************** ВЫКЛЮЧАЕМ ПИТАНИЯ ЧИПА ******************************/
void power_off_for_chip()
{
  digitalWrite(POWER_PIN, LOW); // Выключаем питания на A2 пине
}

/****************************** ПОИСК ЧИПА НА ШИНЕ I2C ******************************/
void search_address_chip()
{
  byte error, address;
  for(address = 1; address < 127; address++ )
  {        
    Wire.beginTransmission(address);
    error = Wire.endTransmission();
    if (error == 0) // Ошибок нет, устройство найдено
    {     
      Eeprom24C04_16 eeprom(address); // Берем адреес шины и пытаемся считать данные с чипа
      eeprom.initialize();
      if (eeprom.readByte(0) != 0xFF) // Считываем нулевой байт, если он 0xFF то ищим следующий адрес 
      {
        address_eeprom = address; // Сохраняем адрес чипа в памяти
        //Serial.print(F("Address chip = 0x"));
        //Serial.println(address,HEX);  // Показываем адрес на котором сидит чип
        break;
      }     
    }
    else if (error==4) //Есть ошибки
    {
      Serial.println(F("error == 4"));
      Serial.println(address,HEX);
    }
  }   
}
 
/****************************** ПРОШИВКА ЧИПА ******************************/
void firmware()
{
  lcd.clear();
  lcd.print(F("FIRMWARE CHIP"));
  lcd.setCursor(0, 1);      
  lcd.blink(); // влючаем мигание курсора для информативности
  Serial.println(F("FIRMWARE START"));
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize();  
  for(int i = 0; i < global_size_dump; i++) // Циклы
  {
    eeprom.writeByte(i, pgm_read_byte(&global_name_dump[i]));  
    delay(10); 

    //Serial.print(pgm_read_byte(&name_dump[i]), HEX);
    //Serial.print(F(" = "));
    //Serial.println(eeprom.readByte(i), HEX);
    //Serial.print(F("number byte = "));
    //Serial.print(i);
    //Serial.print(F(" value byte = "));
    //Serial.print(pgm_read_byte(&name_dump[i]), HEX);
    //Serial.print(F(" eeprom read byte = "));
    //Serial.println(eeprom.readByte(i), HEX);
  }
  Serial.println(F("FIRMWARE END"));
  lcd.print(F("DONE !!!"));
  lcd.noBlink(); // отключаем мигание курсора
  
  // Проверка чипа
  verification_dump();

  // Смена серийного номера чипа если это нужно
  if (global_number_byte_end_of_sn > 0){change_crum_one(global_number_byte_end_of_sn);}
}

/************************************* ПРОВЕРКА ДАМПА ПОСЛЕ ПРОШИВКИ *************************************/
void verification_dump()
{
  lcd.clear();
  lcd.print(F("VERIFICATION"));
  lcd.setCursor(0,1);
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize(); 
  for(int i = 0; i < global_size_dump; i++) // Циклы
  {
    if(pgm_read_byte(&global_name_dump[i]) != eeprom.readByte(i))
    {
      lcd.print(F("ERROR"));
      Serial.print(F("VERIFICATION ERROR"));
      delay(1000);
      break;      
    }
    else
    {
      lcd.print(F("GOOD"));  
      Serial.println(F("VERIFICATION GOOD")); 
      delay(500);
      break;
    }
    //Serial.print(F("number byte = "));
    //Serial.print(i);
    //Serial.print(F(" value byte = "));
    //Serial.print(pgm_read_byte(&name_dump[i]), HEX);
    //Serial.print(F(" eeprom read byte = "));
    //Serial.println(eeprom.readByte(i), HEX);
  }
}

/****************************** ГЕНЕРАТОР СЕРИЙНОГО НОМЕРА ******************************/
void change_crum_one(int address_low_byte_sn)
{  
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize();  
   
  int temp_sn_one = address_low_byte_sn; // Получаем номер байта серийника
  for (int i = 6; i > 0; i--) // меняем 6 младших разрядов серийника
  {   
   int randomNum = random(48, 57); // ANSI (48-58) а в DEC (0-9)
   eeprom.writeByte(temp_sn_one, randomNum); // Записываем значение в адрес
   delay(10); // пауза для записи в ячейку EEPROM 
   temp_sn_one--; // переход к старшему разряду
  }
  Serial.println(F("CHANGE CRUM END"));
  // Показываем серийный номер на lcd
  print_sn_on_lcd();
}

void change_crum_two(int address_low_byte_sn_1, int address_low_byte_sn_2)
{
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize();
  int temp_sn_one = address_low_byte_sn_1;
  int temp_sn_two = address_low_byte_sn_2;
  for (int i = 5; i > 0; i--) // меняем 5 последних разрядов серийника
  {
    int randomNum = random(48, 57); // ANSI (48-58) а в DEC (0-9)
    eeprom.writeByte(temp_sn_one, randomNum); // Записываем значение в адрес
    delay(10); // пауза для записи в ячейку EEPROM
    eeprom.writeByte(temp_sn_two, randomNum); // Записываем значение в адрес
    delay(10); // пауза для записи в ячейку EEPROM
    temp_sn_one--; // переход к старшему разряду
    temp_sn_two--; // переход к старшему разряду
  }
  // выводим на экран сгенерированный серийный номер
  //print_crum();
}

/************************************* ВЫВОД СЕРИЙНОГО НОМЕРА НА LCD *************************************/
void print_sn_on_lcd()
{  
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize();
  //
  lcd.clear();
  lcd.print(F("SERIAL NUMBER"));
  lcd.setCursor(0,1);
  lcd.print(F("CRUM-"));
  lcd.setCursor(5,1);
  //
  Serial.println(F("SERIAL NUMBER")); 
  Serial.print(F("CRUM-")); 
  //
  int temp_start = global_number_byte_end_of_sn - 10;
  int temp_end = global_number_byte_end_of_sn + 1;
  for(int i = temp_start; i < temp_end; i++)
  {
    char c = (char)eeprom.readByte(i); // получаем ascii из hex 
    lcd.print(c);
    Serial.print(c);
  }
  Serial.println(" ");
  // Задержка для просмотра номера
  delay(1000);
}

/************************************* ПОКАЗ ДАМПА НА LCD *************************************/
void read_chip_and_display_it()
{
  power_on_for_chip();
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize();  
  //char c = (char)eeprom.readByte(0); // получил hex to ascii
  int byte_in_str = 16;
  //int sizeof_chip = 128;  // Показываем 8 строк
  int sizeof_chip = 96; // Показываем 6 строк
  int num_str_in_chip = sizeof_chip / byte_in_str;

  for(int i_1 = 0; i_1 < num_str_in_chip; i_1++)
  {
      lcd.clear();
      lcd.print(F("STRING # "));
      lcd.print(i_1);
      for (int i_2 = 0; i_2 < 17; i_2++)
      {
        lcd.setCursor(i_2,1);
        char a = (char)eeprom.readByte(i_2 + i_1 * byte_in_str); // Получаем ascii
        char b; // 
        if (a < 32){ b = 32; } // если a 0 то ставим пробел HEX(32)
        else{ b = a; }
        lcd.print(b); // 15 31 47 63 79 95 111 127
        //lcd.setCursor(i_2,0);
        //Serial.println(eeprom.readByte(i_2 + i_1 * byte_in_str));
      }
      delay(1000);
  }
  lcd.clear();
  /*
  for (int i=0; i < 17; i++)
  {
    char a = (char)eeprom.readByte(i+i2); // Получаем ascii
    char b; // 
    if (a < 32){ b = 32; } // если a 0 то ставим пробел HEX(32)
    else{ b = a; }
    lcd.print(b); // 15 31 47 63 79 95 111 127
    lcd.setCursor(i,0);
    Serial.println(eeprom.readByte(i+i2));
  }
  */
  power_off_for_chip();

  // Показываем текущий чип на экране
  database(global_id); 
}

/************************************* ОТЛАДКА *************************************/
/*
void crum_print(int num_start, int num_end)
{
  
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize();
  Serial.print("CRUM-"); 
  for(int i = num_start; i < num_end; i++)
  {
    char c = (char)eeprom.readByte(i); // получаем ascii из hex 
    Serial.print(c);
  }
  Serial.println(" ");
}
*/

String insert_null(byte num)
{
  // Подставляем ноль если число меньше 10
  if (num < 0x10) {Serial.print("0");} Serial.print(num,HEX);  
}


void test_chip_on_pc(int number_cycle)
{
  power_on_for_chip();
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize(); 
  Serial.println(F("00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F"));
  Serial.println(F(" "));
  for (int i = 0; i < number_cycle; i++)
  {
   if ( i%16 == 0 && i!=0)
   {
     Serial.println(" ");
     insert_null(eeprom.readByte(i)); 
     Serial.print(" ");         
   }
   else
   {
    insert_null(eeprom.readByte(i)); 
    Serial.print(" ");
   }   
  }
  Serial.println(" ");
  power_off_for_chip();

  // Показываем текущий чип на экране
  database(global_id); 
}





