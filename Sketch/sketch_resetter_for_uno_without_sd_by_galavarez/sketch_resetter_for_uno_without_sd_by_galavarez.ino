/* 
Auto Resetter wthiout sd card by Galavarez
* Версия 17.06.2021
- Переписал код базы данных, теперь добавлять новые чипы станет легче. Надеюсь многие поймут что да как =)
- Добавил генератор серийного номера для Ricoh sp4500he 407318
- Добавил 3 дампа для Ricoh SP 360 (Правда черного цвета нет)
- Добавил дамп для Ricoh SP 377 (спасибо за него Титову Анатолию Викторовичу)

* Версия 27.01.2020
- Добавил новый дамп для Ricoh SP 360. Спасибо за ссылку Манакову Юрию

* Версия 15.11.2019
- На днях один из пользователей обнулятора (Манаков Юрий) подкинули идею о чтение дампа через обнулятор. 
Не много поразмыслив, я сделал такую возможность, но с небольшим ограничением. Можно дамп только вывести в монитор порта в ардуино ide (ctrl + shitf + M). 
Потом можно его скопировать в любой hex редактор с разрешением bin. Вот и получался дамп =)
Так же сделал несколько подпрограмм на кнопке SELECT (по любому простаивает).
Инструкция по кнопке селект:
1) Нажимаем на кнопку селект и выбираем подпрограмму (Показ отпечатанных страниц для рико, Таймер обратного отсчета с прошивкой (вернул его) и считывание дампа (128,256,512 байт)
2) Как выбрали подпрограмму (точнее остановились на ней), надо подождать 3 секунды и нажать на кнопку SELECT еще раз.
3) Все, подпрограмма выполнилаль. Надо только попрактиковаться. 
Если будут косяки пишите =)

* Версия 06.11.2019
- Добавил новый дамп для Ricoh SP 310 . Спасибо за ссылку Манакову Юрию 

* Версия 02.11.2019
- Добавил новый дамп для Ricoh SP 330SN 7k (408283). Спасибо за него Руслану Махмутову

* Версия 05.08.2019
- Добавил новый дамп для Ricoh SP 400/450 5k (408061). Спасибо за него Белобородову Михаилу

* Версия 19.07.2019
- Усреднил значения для нового и старого LCD Keypad shield v1 и v1.1. 
Кнопки должны заработать корректно сразу после заливки скетча без правки ручками. Если что в строках 162-166 можно подправить в ручную.
Так же зачения кнопок показываются в "Мониторе порта"

* Версия 03.06.2019
- Исправил значения для нового LCD Keypad shield v. 1.1. Спасибо за наблюдательность Белобородову Михаилу

* Версия 26.03.2019
- Добавил новый дамп для Ricoh Aficio SP С220 С221 С222 С240 (406144, 406145, 406146, 406147). Спасибо за него Юрию Манакову

* Версия 08.02.2019
- Исправлен дамп для Ricoh SP C250/С260 1.6K (407544) Cyan for Ricoh C250/С260. Спасибо за внимательность Белобородову Михаилу

* Версия 07.02.2019
- Добавил новый дамп для Ricoh Aficio SP C252 (407716,407717,407718,407719). Спасибо за него Белобородову Михаилу

* Версия 18.01.2019
- Добавил новый дамп для Ricoh Aficio SP C250/C260 (407543/407544/407545/407546)

* Версия 31.10.2018
- Добавил новый дамп для Ricoh Aficio SP 277 на 2.6K (408160), снят с нового чипа. Спасибо за него Дмитрию Щетневу. Мини реклама =) https://www.youtube.com/user/shetnevdima/featured

* Версия 18.10.2018
- Добавил новый дамп для Ricoh Aficio SP 277 на 2.6K (408160). Спасибо за него 1dx. Дамп надо проверить, отпишитесь по результатам проверки, работает или нет.
- Добавил функцию по проверке количества отпечатанных страниц в картриджах Ricoh. Инструкция: подключить б.у. чип и нажать кнопку SELECT (самая левая).

* Версия 11.09.2018
- Обновил дамп для Ricoh SP 110E 2.6K (407441) for Ricoh SP 111 (SF/SU). Спасибо за него Белобородову Михаилу

* Версия 10.09.2018
- Обновил дамп для Ricoh Aficio SP 200HL на 2.6K (407262). Спасибо за него Белобородову Михаилу

* Версия 09.09.2018
- Добавил новый дамп для Ricoh Aficio SP 311 UXE на 6.4K (821242). Спасибо за него Белобородову Михаилу

* Версия 03.09.2018
- Добавил новый дамп (пока тестируем) для Ricoh Aficio SP 201 series (407261). Спасибо 1dx

* Версия 20.08.2018
- Заменил дамп Xerox PE 220 на новый.

* Версия 18.04.2018
- Исправлен глюк с обнулением картриджей Richo ricoh_sp_211_213_220, ricoh_sp_211_213_220 и ricoh_sp_4510

* Версия 06.03.2018
- Для скоростной записи чипа нужны 2 разные библиотеки 24с01_02 и 24с04_16. Они в папке Library.
- Теперь обнулятор сам выбирает какой библиотекой прошивать чип, опираясь на размер дампа чипа. Если до 256 байт то 24с01_02, иначе 24с04_16.

* Версия 05.03.2018
- На кнопке SELECT будет прошивка чипа с обратным отсчетом. Это удобно когда нужно держать картридж и чип обеими руками. 
- Отсчет 8 секунд до прошивки. Время меняется в функции countdown_timer() переменная timer.

* Версия 04.03.2018
- Новая экспериментальная функция по определению плохого контакта с чипом. На экран будет выведено Concact Bad и тогда нужно будет перезапустить ардуино.
- Так же эта функция доступна по кнопке SELECT она полюбому пока не используется.

* Версия 02.03.2018
- Новая библиотека для работы с чипами, старая глючит при скоростной заливки дампа. Библиотека в папке Library.

* Версия 25.02.2018
- Не большое изменение в коде

* Версия 14.02.2018
- Добавлен круговой поиск чипов т.е. стоя на первом чипе при нажатие кнопки LEFT попадаете на последний чип
- Улучшена скорость записи чипов с 8 - 10 сек до 1 - 3 сек

* Версия 13.02.2018
- Добавил чип Ricoh SP 201HE для SP 211/213/220, принтера нет чтобы проверить прошивку.

* Версия 5.01.2018
- Не большое изменение в коде
- Добавил чип Xerox WC-4118 8k спасибо за дамп copiermaster
- Добавил чип Ricoh SP 3400 3410 (406522) 5k спасибо за дамп copiermaster
- Добавил чип Ricoh SP 3500XE (406990) 6.4k спасибо за дамп copiermaster
- Добавил чип Ricoh SP 4500HE (407318) 12k говорят что подходит к Ricoh SP 3610SF но я это не проверял

* Версия 29.12.2017 
- Переписал код для упрощения добавления новых чипов
- Исправил ошибку в генерации серийного номера
- Исправил некоторые другие ошибки

* Версия 17.12.2017 
- Добавил чип Ricoh SP 210 спасибо за дамп copiermaster

* Версия 25.11.2017 
- Добавил чип Ricoh SP 200, 202, 203 на 2.6К

* Версия 21.11.2017 
- Переписал проверку дампа после заливки его в чип
- Добавил распиновку чипа в правом верхнем углу G - gnd, V - vcc, D - data, C - clock

* Версия 14.11.2017 
- Добавил вывод дампа из чипа на экран по кнопки вниз первых 128 байт

* Версия 03.11.2017 11:17
- Добавил чип Xerox PE 220

* Версия 13.10.2017 14:36
- Добавил проверку на запись дампа в чип 

* Версия 12.10.2017 12:37
- Добавил задержку при подачи питания для стабильности
- Вернул обработку нажатий кнопок для DOWN и SELECT 

* Версия 06.10.2017 19:17
- Добавил чип Ricoh SP 100 (SP 101E)
- Добавил чип Ricoh SP 111 (SP 110E)
- Добавил чип Ricoh SP 150
- Добавил чип Ricoh SP 300
- Добавил чип Ricoh SP 311
- Добавил чип Samsung SCX 4200 (автоматическая смена номера CRUM)
- Добавил чип Xerox WC 3119 (автоматическая смена номера CRUM)
*/

/****************************** ДАМПЫ ЧИПОВ ******************************/

/*********** =====> RICOH <===== *********/

// 24С01_02 // Ricoh SP101E 2K (407059) for Ricoh SP 100 (SF/SU/E)
const PROGMEM char NOTE_SP_100[] = { "SP 100 (SP 101E)" };
const PROGMEM byte dump_ricoh_sp_101e_407059[128] = {
  0x20, 0x00, 0x01, 0x03, 0x03, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x36, 0x39, 0x34, 0x37, 
  0x12, 0x04, 0x4D, 0x41, 0x16, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 110E 2.6K (407441) for Ricoh SP 111 (SF/SU)
const PROGMEM char NOTE_SP_111[] = { "SP 111 (SP 110E)" };
const PROGMEM byte dump_ricoh_sp_110e_407441[128] = {
  0x20, 0x00, 0x01, 0x05, 0x02, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x37, 0x34, 0x34, 0x31, 
  0x17, 0x05, 0x4D, 0x43, 0x01, 0x00, 0x02, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP150HE 1.5K (408010) for Ricoh SP 150 (SU/W/SUw)
const PROGMEM char NOTE_SP_150[] = { "SP 150" };
const PROGMEM byte dump_ricoh_sp_150_408010[128] = {
  0x32, 0x00, 0x01, 0x03, 0x01, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x38, 0x30, 0x31, 0x30, 
  0x16, 0x03, 0x4D, 0x4D, 0x04, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP200HL 2.6K for Ricoh SP SP200/202/203/210/212 (407262) -- новый дамп
const PROGMEM char NOTE_SP_200_202_203_210_212[] = { "200/02/03/10/12" };
const PROGMEM byte dump_ricoh_sp_200_hl_407262[128] = {
  0x21, 0x00, 0x01, 0x03, 0x02, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x37, 0x32, 0x36, 0x32,
  0x13, 0x08, 0x4D, 0x43, 0x13, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP201HE 2.6K (111135) for Ricoh SP201/204/211/213/220 
const PROGMEM char NOTE_SP_201_204_211_213_220[] = { "201/04/11/13/20" };
const PROGMEM byte dump_ricoh_sp_201_hl_111135[128] = {
  0x21, 0x00, 0x01, 0x04, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x31, 0x31, 0x31, 0x31, 0x35, 0x37, 
  0x13, 0x07, 0x4D, 0x43, 0x11, 0x00, 0x14, 0x91, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x01, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 277HE 2.6K series (408160) for Ricoh SP 277NwX / 277SNwX / 277SFNwX
const PROGMEM char NOTE_SP_277[] = { "SP 277" };
const PROGMEM byte dump_ricoh_sp_277_408160[128] = {
  0x21, 0x00, 0x01, 0x03, 0x02, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x38, 0x31, 0x36, 0x30, 
  0x16, 0x01, 0x4D, 0x43, 0x27, 0x00, 0x1F, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP300 1.5K (406956) for Ricoh SP 300DN
const PROGMEM char NOTE_SP_300[] = { "SP 300" };
const PROGMEM byte dump_ricoh_sp_300_406956[128] = {
  0x13, 0x00, 0x01, 0x03, 0x03, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x36, 0x39, 0x35, 0x36, 
  0x11, 0x11, 0x4A, 0x4D, 0x51, 0x00, 0x19, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 311HE 3.5K (407246) for Ricoh SP 311/325 (DNw/SFw/Nw)
const PROGMEM char NOTE_SP_311_325_NORMAL[] = { "SP 311/325" };
const PROGMEM byte dump_ricoh_sp_311_407246[128] = {
  0x07, 0x00, 0x01, 0x03, 0x07, 0x01, 0x01, 0x00, 0x00, 0x00, 0x34, 0x30, 0x37, 0x32, 0x34, 0x36, 
  0x13, 0x00, 0x47, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x58, 0x12, 
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 311UXE 6.4K (821242) for Ricoh SP 311/325 (DNw/SFw/Nw)
const PROGMEM char NOTE_SP_311_325_LARGE[] = { "SP 311/325" };
const PROGMEM byte dump_ricoh_sp_311_821242[128] = {
  0x07, 0x00, 0x01, 0x03, 0x0D, 0x01, 0x01, 0x00, 0x64, 0x00, 0x38, 0x32, 0x31, 0x32, 0x34, 0x32, 
  0x15, 0x10, 0x4D, 0x53, 0x22, 0x00, 0x03, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 3400HE 5K (406522) for Ricoh SP3400/3410/3500/3510
const PROGMEM char NOTE_SP_3400_3410_3500_3510[] = { "3400/10 3500/10" };
const PROGMEM byte dump_ricoh_sp_3400he_406522[128] = {
  0x07, 0x00, 0x01, 0x03, 0x03, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x36, 0x35, 0x32, 0x32, 
  0x11, 0x01, 0x4A, 0x4D, 0x02, 0x01, 0x70, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 3500XE 6.4K (406990) для Ricoh SP3500/3510 (N/DN/SF)
const PROGMEM char NOTE_SP_3500_3510[] = { "ONLY 3500/10" };
const PROGMEM byte dump_ricoh_sp_3500xe_406990[128] = {
  0x07, 0x01, 0x01, 0x03, 0x06, 0x01, 0x01, 0x00, 0x00, 0x00, 0x34, 0x30, 0x36, 0x39, 0x39, 0x30,
  0x12, 0x05, 0x4A, 0x4D, 0x53, 0x00, 0x33, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 4500HE 12K (407318) for Ricoh SP3600/3610/4510 (DN/SF) 
const PROGMEM char NOTE_SP_3600_3610_4510[] = { "SP 3600/10 4510" };
const PROGMEM byte dump_ricoh_sp_4500he_407318[128] = {
  0x23, 0x00, 0x01, 0x03, 0x78, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x37, 0x33, 0x31, 0x38, 
  0x14, 0x09, 0x54, 0x4A, 0x03, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// 24С01_02 // Ricoh SP C250/С260 2K (407543)  Black for Ricoh C250/С260 (DN/DNW/SF/SFNW/FNW)
const PROGMEM char NOTE_SP_C250_260_B[] = { "SP 250/260 B" };
const PROGMEM byte dump_ricoh_sp_c250_c260_407543_black[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x12, 0x01, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30, 0x37, 0x35, 0x34, 0x33, 
  0x14, 0x02, 0x41, 0x42, 0x16, 0x00, 0x1B, 0x32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C250/С260 1.6K (407544) Cyan for Ricoh C250/С260 (DN/DNW/SF/SFNW/FNW)
const PROGMEM char NOTE_SP_C250_260_C[] = { "SP 250/260 C" };
const PROGMEM byte dump_ricoh_sp_c250_c260_407544_cyan[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x0E, 0x02, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30, 0x37, 0x35, 0x34, 0x34, 
  0x14, 0x02, 0x41, 0x42, 0x17, 0x00, 0x16, 0x35, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C250/С260 1.6K (407545) Magenta for Ricoh C250/С260 (DN/DNW/SF/SFNW/FNW)
const PROGMEM char NOTE_SP_C250_260_M[] = { "SP 250/260 M" };
const PROGMEM byte dump_ricoh_sp_c250_c260_407545_magenta[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x0E, 0x03, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30, 0x37, 0x35, 0x34, 0x35, 
  0x14, 0x02, 0x41, 0x42, 0x18, 0x00, 0x11, 0x39, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C250/С260 1.6K (407546) Yellow for Ricoh C250/С260 (DN/DNW/SF/SFNW/FNW)
const PROGMEM char NOTE_SP_C250_260_Y[] = { "SP 250/260 Y" };
const PROGMEM byte dump_ricoh_sp_c250_c260_407546_yellow[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x0E, 0x04, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30, 0x37, 0x35, 0x34, 0x36,
  0x14, 0x02, 0x41, 0x42, 0x19, 0x00, 0x14, 0x36, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C252 6.5K (407716) Black for Ricoh C252
const PROGMEM char NOTE_SP_C252_B[] = { "SP 252 B" }; 
const PROGMEM byte dump_ricoh_sp_c252_407716_black[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x32, 0x01, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x37, 0x37, 0x31, 0x36, 0x14, 0x01, 0x41, 0x42, 0x36, 0x00, 0x36, 0x37,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C252 6K (407717) Cyan for Ricoh C252
const PROGMEM char NOTE_SP_C252_C[] = { "SP 252 C" }; 
const PROGMEM byte dump_ricoh_sp_c252_407717_cyan[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x32, 0x02, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x37, 0x37, 0x31, 0x37, 0x14, 0x05, 0x41, 0x42, 0x37, 0x01, 0x34, 0x35,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C252 6K (407718)  Magenta for Ricoh C252
const PROGMEM char NOTE_SP_C252_M[] = { "SP 252 M" }; 
const PROGMEM byte dump_ricoh_sp_c252_407718_magenta[128] = {
 0xA8, 0x00, 0x01, 0x03, 0x32, 0x03, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
 0x37, 0x37, 0x31, 0x38, 0x14, 0x03, 0x41, 0x42, 0x38, 0x00, 0x38, 0x37,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C252 6K (407719) Yellow for Ricoh C252
const PROGMEM char NOTE_SP_C252_Y[] = { "SP 252 Y" }; 
const PROGMEM byte dump_ricoh_sp_c252_407719_yellow[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x32, 0x04, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x37, 0x37, 0x31, 0x39, 0x14, 0x01, 0x41, 0x42, 0x39, 0x00, 0x36, 0x31,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP С220 С221 С222 С240  2k (406144) Black
const PROGMEM char NOTE_SP_C220_B[] = { "C220-222 240 B" };  
const PROGMEM byte dump_ricoh_sp_c220_221_222_240_406144_black[128] = {
  0xA7, 0x00, 0x01, 0x03, 0x14, 0x01, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x31, 0x34, 0x34, 0x09, 0x05, 0x41, 0x42, 0x62, 0x00, 0x37, 0x39,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP С220 С221 С222 С240  2k (406145) Cyan
const PROGMEM char NOTE_SP_C220_C[] = { "C220-222 240 C" };  
const PROGMEM byte dump_ricoh_sp_c220_221_222_240_406145_cyan[128] = {
  0xA7, 0x00, 0x01, 0x03, 0x14, 0x02, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x31, 0x34, 0x35, 0x09, 0x05, 0x41, 0x42, 0x63, 0x00, 0x14, 0x43,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP С220 С221 С222 С240  2k (406146) Magenta 
const PROGMEM char NOTE_SP_C220_M[] = { "C220-222 240 M" }; 
const PROGMEM byte dump_ricoh_sp_c220_221_222_240_406146_magenta[128] = {
  0xA7, 0x00, 0x01, 0x03, 0x14, 0x03, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x31, 0x34, 0x36, 0x09, 0x05, 0x41, 0x42, 0x64, 0x00, 0x22, 0x29,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP С220 С221 С222 С240  2k (406147) Yellow 
const PROGMEM char NOTE_SP_C220_Y[] = { "C220-222 240 Y" }; 
const PROGMEM byte dump_ricoh_sp_c220_221_222_240_406147_yellow[128] = {
  0xA7, 0x00, 0x01, 0x03, 0x14, 0x04, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x31, 0x34, 0x37, 0x09, 0x11, 0x41, 0x42, 0x65, 0x00, 0x07, 0x24,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP SP 400/450  5k (408061)
const PROGMEM char NOTE_SP_400_450[] = { "SP 400/450" }; 
const PROGMEM byte dump_ricoh_sp_400_450[128] = {
 0x23, 0x00, 0x01, 0x03, 0x32, 0x01, 0x30, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x38, 0x30, 0x36, 0x31, 0x16, 0x02, 0x54, 0x4A, 0x29, 0x00, 0x02, 0x51,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// 24С01_02 // Ricoh SP330H 7K (408283) for Ricoh Ricoh SP 330
const PROGMEM char NOTE_SP_330[] = { "SP 330" }; 
const PROGMEM byte dump_ricoh_sp_330_408283[128] = {
  0x45, 0x00, 0x01, 0x04, 0x0E, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x38, 0x32, 0x38, 0x33, 0x18, 0x07, 0x52, 0x47, 0x14, 0x00, 0x32, 0x38,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP310 cyan (122700) for Ricoh Ricoh SP 310
const PROGMEM char NOTE_SP_310_C[] = { "SP 310 C" }; 
const PROGMEM byte dump_ricoh_sp_310_122700_cyan[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x32, 0x02, 0x01, 0xFF, 0x64, 0x00, 0x31, 0x32,
  0x32, 0x37, 0x30, 0x30, 0x09, 0x03, 0x41, 0x42, 0x17, 0x00, 0x17, 0x06,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP310 black (406479) for Ricoh Ricoh SP 310
const PROGMEM char NOTE_SP_310_B[] = { "SP 310 B" };
const PROGMEM byte dump_ricoh_sp_310_406479_black[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x32, 0x01, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x34, 0x37, 0x39, 0x11, 0x07, 0x41, 0x42, 0x16, 0x00, 0x37, 0x80,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// 24С01_02 // Ricoh SP310 magenta (122728) for Ricoh Ricoh SP 310
const PROGMEM char NOTE_SP_310_M[] = { "SP 310 M" };
const PROGMEM byte dump_ricoh_sp_310_122728_magenta[128] = {
0xA8, 0x00, 0x01, 0x03, 0x32, 0x03, 0x01, 0xFF, 0x64, 0x00, 0x31, 0x32,
  0x32, 0x37, 0x32, 0x38, 0x09, 0x11, 0x41, 0x42, 0x18, 0x00, 0x11, 0x32,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP310 yellow (406482) for Ricoh Ricoh SP 310
const PROGMEM char NOTE_SP_310_Y[] = { "SP 310 Y" };
const PROGMEM byte dump_ricoh_sp_310_406482_yellow[128] = {
0xA8, 0x00, 0x01, 0x03, 0x32, 0x04, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x34, 0x38, 0x32, 0x11, 0x07, 0x41, 0x42, 0x19, 0x00, 0x02, 0x50,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP360 cyan (408177)
const PROGMEM char NOTE_SP_360_C[] = { "SP 360 C" };
const PROGMEM byte dump_ricoh_sp_360_408177_cyan[128] = {
  0x2F, 0x00, 0x01, 0x02, 0x2A, 0x02, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x38, 0x31, 0x37, 0x37, 0x17, 0x07, 0x54, 0x4A, 0x07, 0x00, 0x25, 0x4E,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP360 magenta (408178)
const PROGMEM char NOTE_SP_360_M[] = { "SP 360 M" };
const PROGMEM byte dump_ricoh_sp_360_408178_magenta[128] = {
  0x2F, 0x00, 0x01, 0x02, 0x2D, 0x03, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x38, 0x31, 0x37, 0x38, 0x17, 0x02, 0x54, 0x4A, 0x07, 0x00, 0x26, 0x4F,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP360 yellow (408179)
const PROGMEM char NOTE_SP_360_Y[] = { "SP 360 Y" };
const PROGMEM byte dump_ricoh_sp_360_408179_yellow[128] = {
 0x2F, 0x00, 0x01, 0x02, 0x27, 0x04, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x38, 0x31, 0x37, 0x39, 0x17, 0x01, 0x54, 0x4A, 0x07, 0x00, 0x26, 0x46,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Ricoh SP377 6.4K (408162) => Aficio SP 377DNwX/377SFNwX 
const PROGMEM char NOTE_SP_377[] = { "SP 377" };
const PROGMEM byte DUMP_SP_377[128] = {
  0x07, 0x02, 0x01, 0x02, 0x0D, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x38, 0x31, 0x36, 0x31, 0x16, 0x02, 0x4D, 0x53, 0x27, 0x00, 0x07, 0x56,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
/*********** =====> SAMSUNG <===== *********/

// 24С04_16 // Samsung SCX-D4200A 3K for Samsung SCX-4200/4220 
const PROGMEM char NOTE_SCX_D4200[] = { "SCX 4200/20" }; 
const PROGMEM byte dump_samsung_scx_d4200a[512] = {
  0x43, 0x34, 0x32, 0x30, 0x30, 0x45, 0x58, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x31, 0x33, 0x30, 0x37, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x31, 0x33, 0x30, 0x37, 0x32, 0x35, 0x33, 0x32, 0x31, 0x31, 0x35, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x34, 0x32, 0x30, 0x30, 0x45, 0x58, 0x50,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xDD, 0x00, 0x22, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

/*********** =====> XEROX <===== *********/

// 24С04_16 // Xerox 013R00625 3K for XEROX WC 3119
const PROGMEM char NOTE_WC_3119[] = { "WC 3119" };
const PROGMEM byte dump_xerox_013R00625[512] = {
  0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x30, 0x36, 0x30, 0x36, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x30, 0x36, 0x30, 0x36, 0x32, 0x39, 0x30, 0x39, 0x33, 0x31, 0x34, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xDD, 0x00, 0x22, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x43, 0x72, 0x75, 0x6D, 0x20, 0x42, 0x79, 0x20,
  0x48, 0x77, 0x61, 0x6E, 0x67, 0x2E, 0x73, 0x6B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// 24С04_16 // Xerox 013R00621 2K for XEROX PE 220
const PROGMEM char NOTE_PE_220[] = { "PE 220" };
const PROGMEM byte dump_xerox_013R00621[512] = {
  0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x30, 0x36, 0x30, 0x34, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x30, 0x36, 0x30, 0x34, 0x30, 0x36, 0x33, 0x33, 0x35, 0x38, 0x35, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// 24С04_16 // Xerox 006R01278 8K for Xerox WC 4118 
const PROGMEM char NOTE_WC_4118[] = { "WC 4118" };
const PROGMEM byte dump_xerox_006R01278[512] = {
  0x20, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x32, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x30, 0x38, 0x30, 0x32, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x30, 0x38, 0x30, 0x32, 0x30, 0x36, 0x31, 0x36, 0x30, 0x30, 0x31, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x32, 0x20,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x30, 0x38, 0x30, 0x32, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x30, 0x38, 0x30, 0x32, 0x30, 0x36, 0x31, 0x36, 0x30, 0x30, 0x31,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x32,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};


/** НАЧАЛО **/

// Подключаем библиотеку которая позволяет управлять микросхемами 24CXX подключать их на ПИН A4 (SDA), A5 (SCL)
#include <Eeprom24C01_02.h> // Библиотека работает с 24C01 24C02
#include <Eeprom24C04_16.h> // Библиотека работает с 24C04 24C08 24C16
// Подключаем библиотеку которая позволяет взаимодействовать с различными устройствами по интерфейсу I2C / TWI.
#include <Wire.h> 
// Подключаем библиотеку которая позволяет управлять различными жидкокристаллическими дисплеями (LCD)
#include <LiquidCrystal.h>  
// Подключаем библиотеку для записи статических строк во FLASH а не в RAM 
// Serial.print(F(Тут_статическая_строка)) или const PROGMEM до вызова SETUP
// Serial.println(pgm_read_byte(&dump_ricoh_sp_150[i]), HEX); чтение переменной без изменений из FLASH
#include <avr/pgmspace.h>

// Пины LCD 1602 (RS, E, D4, D5, D6, D7)
LiquidCrystal lcd( 8, 9, 4, 5, 6, 7 );

// Пин питания у Вас может быть другой
#define POWER_PIN A2
// Пин для работы генератора случайных чисел
#define RANDOM_PIN A3

// Адрес чипа (адрес динамический, меняется от чипа к чипу)
byte address_eeprom;

// Номер чипа по умолчанию
byte global_id = 0;

// Кол-во чипов в базе данных
int global_all_chip_in_database;

// Имя дампа
const byte* global_name_dump;

// Размер чипа
int global_size_dump;

// Номер функции которая помняет серийник 0 -- замена не нужна
int global_change_crum;

// Состояние кнопки (защита от повторного срабатывания)
boolean global_button_press = false; // true - кнопка нажата

// Время отсчета для кнопки SELECT
unsigned long time_passed = 0; 

// Запоминаем количество нажатий на кнопку
int global_button_select = 0; 

// Значение кнопок для разных версий LCD Keypad shield. 
// Настроить под себя если клавиатура плохо работает.
// Указать значение БОЛЬШЕ чем у вас выдает кнопка
                              // LCD Keypad shield v 1        // LCD Keypad shield v 1.1  (тестировал на 2х Keypad shield)   
int BUTTON_UP = 110;          // Пример у меня значение 132   // 96 или 100
int BUTTON_DOWN = 270;        // Пример у меня значение 334   // 251 или 255
int BUTTON_RIGHT = 5;        // Пример у меня значение 3     // 0 или 0
int BUTTON_LEFT = 410;        // Пример у меня значение 482   // 404 или 407
int BUTTON_SELECT = 650;      // Пример у меня значение 720   // 637 или 638


// ** DEFINE ** //
// => BRAND
const PROGMEM char BRAND_RICOH[] = { "RICOH" };
const PROGMEM char BRAND_SAMSUNG[] = { "SAMSUNG" };
const PROGMEM char BRAND_XEROX[] = { "XEROX" };
// => PINOUT
const PROGMEM char PINOUT_GVCD[] = { "GVCD" };
const PROGMEM char PINOUT_GVDC[] = { "GVDC" };
const PROGMEM char PINOUT_VDCG[] = { "VDCG" };
const PROGMEM char PINOUT_GCDV[] = { "GCDV" };
// => PAGE
const PROGMEM char PAGE_1_5_K[] = { "1.5K" };
const PROGMEM char PAGE_2_K[] = { "2K" };
const PROGMEM char PAGE_2_6_K[] = { "2.6K" };
const PROGMEM char PAGE_3_K[] = { "3K" };
const PROGMEM char PAGE_3_5_K[] = { "3.5K" };
const PROGMEM char PAGE_5_K[] = { "5K" };
const PROGMEM char PAGE_6_K[] = { "6K" };
const PROGMEM char PAGE_6_4_K[] = { "6.4K" };
const PROGMEM char PAGE_6_5_K[] = { "6.5K" };
const PROGMEM char PAGE_7_K[] = { "7K" };
const PROGMEM char PAGE_8_K[] = { "8K" };
const PROGMEM char PAGE_12_K[] = { "12K" };
// => CHIP_MEMORY
const PROGMEM int CHIP_MEMORY_128 = 128;
const PROGMEM int CHIP_MEMORY_512 = 512;

/** Создаем структуру базы данных (проще говоря многомерный массив с разными данными) **/
struct Struct_DB
{
  const char* brand;
  const char* page;
  const char* pinout;
  const char* note;
  const byte* dump;
  const int chip_memory;
  const int change_crum;
};

/** База Данных **/
Struct_DB datebase[] = {
  // Brand, Page, Pinuot, Name, Name_Dump, Size, Crum
  // Crum 0 = Ни чего не делать ; 1 = Генерация 1 серийника Samsung|Xerox ; 2 - Генерация 2х серийников Samsung|Xerox; 3 - Генерация 1 серийника Ricoh  

  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVCD, NOTE_SP_100, dump_ricoh_sp_101e_407059, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_6_K, PINOUT_GVCD, NOTE_SP_111, dump_ricoh_sp_110e_407441, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_1_5_K, PINOUT_GVCD, NOTE_SP_150, dump_ricoh_sp_150_408010, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_6_K, PINOUT_GVCD, NOTE_SP_200_202_203_210_212, dump_ricoh_sp_200_hl_407262, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_6_K, PINOUT_GVCD, NOTE_SP_201_204_211_213_220, dump_ricoh_sp_201_hl_111135,CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C220_B, dump_ricoh_sp_c220_221_222_240_406144_black, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C220_C, dump_ricoh_sp_c220_221_222_240_406145_cyan, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C220_M, dump_ricoh_sp_c220_221_222_240_406146_magenta, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C220_Y, dump_ricoh_sp_c220_221_222_240_406147_yellow, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C250_260_B, dump_ricoh_sp_c250_c260_407543_black, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C250_260_M, dump_ricoh_sp_c250_c260_407545_magenta, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C250_260_Y, dump_ricoh_sp_c250_c260_407546_yellow, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C250_260_C, dump_ricoh_sp_c250_c260_407544_cyan, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_5_K, PINOUT_GVDC, NOTE_SP_C252_B, dump_ricoh_sp_c252_407716_black, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_C252_C, dump_ricoh_sp_c252_407717_cyan, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_C252_M, dump_ricoh_sp_c252_407718_magenta, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_C252_Y, dump_ricoh_sp_c252_407719_yellow, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_6_K, PINOUT_GVCD, NOTE_SP_277, dump_ricoh_sp_277_408160, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_1_5_K, PINOUT_GVDC, NOTE_SP_300, dump_ricoh_sp_300_406956, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_310_B, dump_ricoh_sp_310_406479_black, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_310_Y, dump_ricoh_sp_310_406482_yellow, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_310_M, dump_ricoh_sp_310_122728_magenta, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_310_C, dump_ricoh_sp_310_122700_cyan, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_3_5_K, PINOUT_GVCD, NOTE_SP_311_325_NORMAL, dump_ricoh_sp_311_407246, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_4_K, PINOUT_GVCD, NOTE_SP_311_325_LARGE, dump_ricoh_sp_311_821242, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_7_K,   PINOUT_GVCD, NOTE_SP_330, dump_ricoh_sp_330_408283, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_4_K, PINOUT_GVCD, NOTE_SP_377, DUMP_SP_377, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_5_K,   PINOUT_GVCD, NOTE_SP_400_450, dump_ricoh_sp_400_450, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_5_K,   PINOUT_GVDC, NOTE_SP_3400_3410_3500_3510, dump_ricoh_sp_3400he_406522, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_4_K, PINOUT_GVDC, NOTE_SP_3500_3510, dump_ricoh_sp_3500xe_406990, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_12_K,  PINOUT_GVCD, NOTE_SP_3600_3610_4510, dump_ricoh_sp_4500he_407318, CHIP_MEMORY_128, 3 },      // 3 функция с 23 начало
  { BRAND_SAMSUNG,  PAGE_3_K,   PINOUT_VDCG, NOTE_SCX_D4200, dump_samsung_scx_d4200a, CHIP_MEMORY_512 , 1 },                 // 1 функция с 63 начало
  { BRAND_XEROX,    PAGE_2_K,   PINOUT_VDCG, NOTE_PE_220, dump_xerox_013R00621, CHIP_MEMORY_512, 1 },                              // 1 функция с 63 начало
  { BRAND_XEROX,    PAGE_3_K,   PINOUT_VDCG, NOTE_WC_3119, dump_xerox_013R00625, CHIP_MEMORY_512 , 1 },                             // 1 функция с 63 начало
  { BRAND_XEROX,    PAGE_8_K,   PINOUT_GCDV, NOTE_WC_4118, dump_xerox_006R01278, CHIP_MEMORY_512 , 2 },                             // 2 функция с 63 начало и 191
  { BRAND_RICOH,    PAGE_5_K,   PINOUT_GVDC, NOTE_SP_360_Y, dump_ricoh_sp_360_408179_yellow, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_5_K,   PINOUT_GVDC, NOTE_SP_360_M, dump_ricoh_sp_360_408178_magenta, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_5_K,   PINOUT_GVDC, NOTE_SP_360_C, dump_ricoh_sp_360_408177_cyan, CHIP_MEMORY_128 , 0 }           // Последняя строка без запятой !!!
 
  // { "", "", "", , sizeof(), 0 }, // шаблон 
};

void set_global_variables(int row)
{
  // Показываем на LCD brand, page, pinout, note
  lcd.clear();
  lcd.setCursor(0,0);
  for(byte i1=0; i1 < strlen_P(datebase[row].brand); i1++){ lcd.print((char)pgm_read_byte(&datebase[row].brand[i1])); }   
  lcd.print(" ");
  for(byte i2=0; i2 < strlen_P(datebase[row].page); i2++){ lcd.print((char)pgm_read_byte(&datebase[row].page[i2])); }  
  lcd.setCursor(12,0);
  for(byte i3=0; i3 < strlen_P(datebase[row].pinout); i3++){ lcd.print((char)pgm_read_byte(&datebase[row].pinout[i3])); }  
  lcd.setCursor(0,1);  
  for(byte i4=0; i4 < strlen_P(datebase[row].note); i4++){ lcd.print((char)pgm_read_byte(&datebase[row].note[i4])); }
  
  // Устанавливаем глобальные переменные dump chip_memory change_crum
  global_name_dump = datebase[row].dump;
  global_size_dump = datebase[row].chip_memory; 
  global_change_crum = datebase[row].change_crum;
}

/****************************** SETUP ******************************/


void setup() 
{   
  lcd.begin(16, 2);  // Инициализируем LCD 16x2
  Serial.begin(9600); //инициализируем последовательное соединение для работы с ПК
  while (!Serial) { ; } // Ждем когда подключится ардуино к пк по usb
  Wire.begin(); //инициализируем библиотеку I2C / TWI для работы с I2C устройствами
 
  // Пин А2 для питания чипа устанавливаем в положение OUTPUT
  // Пин A0-14 A1-15 A2-16 A3-17 A4-18 A5-19
  pinMode(POWER_PIN, OUTPUT);
  
  // Пин А3 для работы генератора случайных чисел
  randomSeed(analogRead(RANDOM_PIN));

  // Подсчитываем сколько чипов в Базе 
  global_all_chip_in_database = ( sizeof(datebase) / sizeof(Struct_DB) ) - 1 ; 
  //Serial.print("Rows in DB => ");
  //Serial.println( global_all_chip_in_database );
  
  // Устанавливаем глобальные переменные и показываем первый чип на экране
  set_global_variables(global_id);

  
}


/****************************** LOOP ******************************/


void loop() 
{  
  /* ОБРАБОТКА НАЖАТИЯ КНОПОК */

  // Задаем номер порта с которого производим считывание
  int analog_number = analogRead(0); 
  //Serial.println(analog_number);

  
  if (analog_number < BUTTON_RIGHT && global_button_press == false) // Если это кнопка Right и другие кнопки не нажаты то
  {     
    // Значение кнопки
    print_sensor_value("RIGHT");
    
    if (analog_debonce(BUTTON_RIGHT) == true) // делаем проверку от дребезга кнопок
    {
        
      if (global_id != global_all_chip_in_database)
      {
        // Увеличиваем счетчик и показываем на экране следующий чип
        global_id++;
        set_global_variables(global_id);
      }
      else
      {
        // Показываем на экране 1 чип
        global_id = 0;
        set_global_variables(global_id);
      }
      
    }
  }
  else if (analog_number < BUTTON_UP && global_button_press == false) // Если это кнопка UP и другие кнопки не нажаты то
  {
    // Значение кнопки
    print_sensor_value("UP");
    
    if (analog_debonce(BUTTON_UP) == true) // делаем проверку от дребезга кнопок
    {
      // Serial.println(F("CLICK BUTTON UP")); // UPLOAD -- закачиваем дамп
      // Подаем питание и сканируем шину i2c на наличие чипа
      power_on_for_chip();
      
      // Скоростная прошивка чипа
      // если дамп чипа меньше либо равна 256 байт то это микросхема 24c01_02 иначе это 24c04_16
      if(global_size_dump <= 256)
      {
        firmware_24c01_02();
      }
      else
      {
        firmware_24c04_16();
      }
      
      // Выключаем питание
      power_off_for_chip();

      // Возврат в меню
      set_global_variables(global_id);

    }
  }
  else if (analog_number < BUTTON_DOWN && global_button_press == false) // Если это кнопка Down и другие кнопки не нажаты то
  {
    // Значение кнопки
    print_sensor_value("DOWN");
    
    if (analog_debonce(BUTTON_DOWN) == true) // делаем проверку от дребезга кнопок
    {
      // Подаем питание и сканируем шину i2c на наличие чипа
      power_on_for_chip();
      
      // Считываем чип и показываем его на lcd
      read_chip_and_display_it();  
      
      // Чтение дампа и вывод его в порт монитора
      // extract_dump();    
      
      // Выключаем питание
      power_off_for_chip();

      // Возврат в меню
      set_global_variables(global_id);
    }
  }
  else if (analog_number < BUTTON_LEFT && global_button_press == false) // Если это кнопка Left и другие кнопки не нажаты то
  {
    // Значение кнопки
    print_sensor_value("LEFT");
    
    if (analog_debonce(BUTTON_LEFT) == true) // делаем проверку от дребезга кнопок
    {
        
      if (global_id != 0)
      {
        // Уменьшаем счетчик и показываем предыдущий чип
        global_id--; 
        set_global_variables(global_id);
      }
      else
      {
        // Показываем на экране последний чип в базе данных
        global_id = global_all_chip_in_database; 
        set_global_variables(global_id);
      }
    }
  }
  else if (analog_number < BUTTON_SELECT && global_button_press == false) // Если это кнопка Select и другие кнопки не нажаты то
  {    
    // Значение кнопки
    print_sensor_value("SELECT");    
    
    if (analog_debonce(BUTTON_SELECT) == true)  // делаем проверку от дребезга кнопок
    {
        // Если time_passed раверн 0 значит нажали внопку в первый раз
        if ( time_passed == 0) 
        { 
          time_passed = millis(); // Запоминаем время нажатие кнопки 
        }
        else if ( (millis() - time_passed) < 3000 ) // Если нажание на кнопку было МЕНЬШЕ 3х секунд назад т.е. листаем меню
        {
          global_button_select++; // Увеличиваем счетчик меню
        }

        // Если повторное нажатие кнопки SELECT было БОЛЬШЕ 3х секунд назад, выполняем запуск выбранной функции
        if ( millis() - time_passed > 3000) 
        {
           // Выполнаем функции
           switch(global_button_select)
           {
            case 0:
              total_pages_on_display_ricoh(); // Показываем на дисплей количество страниц из чипа (только для Ricoh)
              break;
            case 1:
              firmware_chip_with_timer(5); // В скобках сколько секунд ждать перед пршивкой   
              break;
            case 2:
              extract_dump(128);  // Показываем в мониторе порта дамп с чипа первые 128 байт      
              break;
            case 3:
              extract_dump(256);  // Показываем в мониторе порта дамп с чипа первые 256 байт       
              break; 
            case 4:
              extract_dump(512);   // Показываем в мониторе порта дамп с чипа первые 512 байт         
              break;  
           }
           // Обнуляем переменные времени и количество нажатий на кнопку
           time_passed = 0;
           global_button_select = 0;
        }
        else // Иначе листаем меню
        {
          restart_switch: // точка возварат switch по default
          
          switch(global_button_select)
          {
            case 0:
              lcd.clear();
              lcd.print(F("NUMBER PRINTED")); 
              lcd.setCursor(0,1);
              lcd.print(F("PAGES ON PRINTER"));               
              break;
            case 1:
              lcd.clear();
              lcd.print(F("FIRMWARE CHIP"));
              lcd.setCursor(0,1);
              lcd.print(F("WITH TIMER"));
              break;
            case 2:
              lcd.clear();
              lcd.print(F("READ DUMP ON PC"));
              lcd.setCursor(0,1);
              lcd.print(F("128 BYTES"));             
              break;
            case 3:
              lcd.clear();
              lcd.print(F("READ DUMP ON PC"));
              lcd.setCursor(0,1);
              lcd.print(F("256 BYTES"));
              break;
            case 4:
              lcd.clear();
              lcd.print(F("READ DUMP ON PC"));
              lcd.setCursor(0,1);
              lcd.print(F("512 BYTES"));
              break;
            default:
              // Обнуление перемен и возварт в начало меню
              global_button_select = 0;
              goto restart_switch;
          }
          time_passed = millis(); // Запоминаем время когда нажали кнопку
        } 
    }   
  }
  
  // Обнуляем переменную globalBntPress если все кнопки отпущены
  if ( analogRead(0) > 1000){ global_button_press = false;}
   
}

/****************************** ПРОВЕРКА ЗНАЧЕНИЙ КНОПОК ******************************/
void print_sensor_value(String name_button)
{
  Serial.println(F(""));
  Serial.print(F("Значение выдаваемое кнопкой "));
  Serial.print(name_button);
  Serial.print(F(":"));
  Serial.println(analogRead(0)); // Проверка кнопок, какие они выдают значения.
}


/****************************** ЗАЩИТА ОТ ДРЕБЕЗГА КНОПОК И ПОВТОРНЫХ НАЖАТИЙ ******************************/

boolean analog_debonce(int max_value)
{

  delay(50); // Пауза перед повторным считыванием кнопки
  if ( analogRead(0) < max_value) // Если все еще держим кнопку а не случайный дребезг то
  {
    global_button_press = true; // Запоминаем что нажали кнопку
    return true; // Проверка на дребегз пройдена
  }
  else
  {
    return false; // Проверка на дребегз НЕ пройдена
  }
}

/****************************** ВКЛЮЧАЕМ ПИТАНИЯ ЧИПА ******************************/

void power_on_for_chip()
{
  digitalWrite(POWER_PIN, HIGH); // Подаем питания на A2 для запитки чипа
  delay(500); // Задержка для поднятия напряжения
  search_address_chip_2(); // Сканируем шину I2C на наличия чипа и сохраняем адрес его в памяти
}

/****************************** ВЫКЛЮЧАЕМ ПИТАНИЯ ЧИПА ******************************/
void power_off_for_chip()
{
  digitalWrite(POWER_PIN, LOW); // Выключаем питания на A2 пине
}

/****************************** ПОИСК ЧИПА НА ШИНЕ I2C ******************************/
void search_address_chip()
{
  byte error, address;
  for(address = 1; address < 127; address++)
  {        
    Wire.beginTransmission(address);
    error = Wire.endTransmission();
    if (error == 0) // Ошибок нет, устройство найдено
    {     
      Eeprom24C04_16 eeprom(address); // Берем адреес шины и пытаемся считать данные с чипа
      eeprom.initialize();
      if (eeprom.readByte(0) != 0xFF) // Считываем нулевой байт, если он 0xFF то ищим следующий адрес 
      {
        address_eeprom = address; // Сохраняем адрес чипа в памяти
        //Serial.print(F("Address chip = 0x"));
        //Serial.println(address,HEX);  // Показываем адрес на котором сидит чип
        break;
      }     
    }
    else if (error==4) //Есть ошибки
    {
      Serial.println(F("error == 4"));
      Serial.println(address,HEX);
    }
  }   
}

/****************************** ПОИСК ЧИПА НА ШИНЕ I2C ВЕРСИЯ 2 ******************************/
void search_address_chip_2()
{
  // По умолчанию считается что контакта с чипом нет (если все хорошо то этого сообщения не увидите)
  lcd.clear(); lcd.print(F("CONTACT CHIP"));  lcd.setCursor(0,1); lcd.print(F("BAD"));
     
  byte error, address;
  for(address = 1; address < 127; address++)
  {        
    Wire.beginTransmission(address);
    error = Wire.endTransmission();
    if (error == 0) // Ошибок нет, устройство найдено
    {     
      Eeprom24C04_16 eeprom(address); // Берем адреес шины и пытаемся считать данные с чипа
      eeprom.initialize();
      if (eeprom.readByte(0) != 0xFF) // Считываем нулевой байт, если он 0xFF то ищим следующий адрес 
      {
        address_eeprom = address; // Сохраняем адрес чипа в памяти
        //Serial.print(F("Address chip = 0x"));
        //Serial.println(address,HEX);  // Показываем адрес на котором сидит чип
        
        //Serial.println("Contact GOOD");
        lcd.setCursor(0,1); lcd.print(F("GOOD")); // Контакт есть
                
        break;
      }     
    }
    else if (error==4) //Есть ошибки
    {
      Serial.println(F("error == 4"));
      Serial.println(address,HEX);
    }
  }   
}
 
/****************************** МЕДЛЕННАЯ ПРОШИВКА ЧИПА ******************************/
void firmware()
{
  lcd.clear();
  lcd.print(F("FIRMWARE CHIP"));
  lcd.setCursor(0, 1);      
  lcd.blink(); // влючаем мигание курсора для информативности
  Serial.println(F("FIRMWARE START"));

  Eeprom24C04_16 eeprom(address_eeprom); 
  eeprom.initialize();
   
  for(int i = 0; i < global_size_dump; i++) // Циклы
  {
    eeprom.writeByte(i, pgm_read_byte(&global_name_dump[i]));  
    delay(10); 

    //Serial.print(pgm_read_byte(&name_dump[i]), HEX);
    //Serial.print(F(" = "));
    //Serial.println(eeprom.readByte(i), HEX);
    //Serial.print(F("number byte = "));
    //Serial.print(i);
    //Serial.print(F(" value byte = "));
    //Serial.print(pgm_read_byte(&name_dump[i]), HEX);
    //Serial.print(F(" eeprom read byte = "));
    //Serial.println(eeprom.readByte(i), HEX);
  }
  Serial.println(F("FIRMWARE END"));
  lcd.print(F("DONE !!!"));
  lcd.noBlink(); // отключаем мигание курсора
  
  // Проверка чипа
  verification_dump();
}

/****************************** СКОРОСТНАЯ ПРОШИВКА ЧИПОВ 24c01-02 до 256 байт в чипе ******************************/
void firmware_24c01_02()
{
  lcd.clear();
  lcd.print(F("FIRMWARE CHIP"));
  lcd.setCursor(0, 1);      
  lcd.blink(); // влючаем мигание курсора для информативности
  Serial.println(F("FIRMWARE START"));

  // Скоростная прошивка чипа
  Eeprom24C01_02 eeprom(address_eeprom); eeprom.initialize(); 
  
  word address = 0; // Адрес начало дампа
  int count = global_size_dump; // байт в чипе
  
  byte array_bytes[count];  // Создаем массив с нужным размером 
  for (int i = 0; i < count; i++) 
  {    
    array_bytes[i] = pgm_read_byte(&global_name_dump[i]); // Заполняем массив
    //Serial.println(pgm_read_byte(&global_name_dump[i]), HEX);
  }
  eeprom.writeBytes(address, count, array_bytes); // Записываем в чип
  //Serial.println(address);
  //Serial.println(count);
  
  lcd.print(F("DONE !!!"));
  lcd.noBlink(); // отключаем мигание курсора

  // Проверка чипа
  verification_dump();

  //Смена серийного номера
  change_crum_select();
}

/****************************** СКОРОСТНАЯ ПРОШИВКА ЧИПОВ 24c04-16 более 512 байт в чипе ******************************/
void firmware_24c04_16()
{
  lcd.clear();
  lcd.print(F("FIRMWARE CHIP"));
  lcd.setCursor(0, 1);      
  lcd.blink(); // влючаем мигание курсора для информативности
  Serial.println(F("FIRMWARE START"));

  // Скоростная прошивка чипа
  Eeprom24C04_16 eeprom(address_eeprom); 
  eeprom.initialize();   

  word address = 0; // Адрес начало дампа
  int count = global_size_dump; // байт в чипе
  
  byte array_bytes[count];  // Создаем массив с нужным размером 
  for (int i = 0; i < count; i++) 
  {    
    array_bytes[i] = pgm_read_byte(&global_name_dump[i]); // Заполняем массив
    //Serial.println(pgm_read_byte(&global_name_dump[i]), HEX);
  }
  eeprom.writeBytes(address, count, array_bytes); // Записываем в чип
  
  lcd.print(F("DONE !!!"));
  lcd.noBlink(); // отключаем мигание курсора

  // Проверка чипа
  verification_dump();

  //Смена серийного номера
  change_crum_select();
}

/************************************* ПРОВЕРКА ДАМПА ПОСЛЕ ПРОШИВКИ *************************************/
void verification_dump()
{
  lcd.clear();
  lcd.print(F("VERIFICATION"));
  lcd.setCursor(0,1);
  
  Eeprom24C04_16 eeprom(address_eeprom); 
  eeprom.initialize();  
    
  for(int i = 0; i < global_size_dump; i++) // Циклы
  {
    if(pgm_read_byte(&global_name_dump[i]) != eeprom.readByte(i))
    {
      lcd.print(F("ERROR"));
      Serial.print(F("VERIFICATION ERROR"));
      delay(1000);
      break;      
    }
    else
    {
      lcd.print(F("GOOD"));  
      Serial.println(F("VERIFICATION GOOD")); 
      delay(500);
      break;
    }
    //Serial.print(F("number byte = "));
    //Serial.print(i);
    //Serial.print(F(" value byte = "));
    //Serial.print(pgm_read_byte(&name_dump[i]), HEX);
    //Serial.print(F(" eeprom read byte = "));
    //Serial.println(eeprom.readByte(i), HEX);
  }
}


/** ГЕНЕРАТОР СЕРИЙНОГО НОМЕРА ВЕРСИЯ 3 **/
// Выбор какая функция смены серийного номера заработает
void change_crum_select()
{  
  switch (global_change_crum)
  {
    case 0:
      break;
    case 1: 
      change_crum_one_samsung_xerox();
      break;
    case 2:
      change_crum_two_xerox();
      break;
    case 3:
      change_crum_ricoh();
      break;
    default:
      break;
  }
}


// Генератора для Samsung или Xerox где надо сменить 1 номер 
// Младший разряд находится в 63 байте
// ...
void change_crum_one_samsung_xerox()
{  
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize(); 
   
  int temp_sn_one = 63; // Получаем номер байта серийника
  for (int i = 6; i > 0; i--) // меняем 6 младших разрядов серийника
  {   
   int randomNum = random(48, 57); // ANSI (48-58) а в DEC (0-9)
   eeprom.writeByte(temp_sn_one, randomNum); // Записываем значение в адрес
   delay(10); // пауза для записи в ячейку EEPROM 
   temp_sn_one--; // переход к старшему разряду
  }
  Serial.println(F("CHANGE CRUM 1 END"));
  // Показываем серийный номер на lcd
  print_sn_on_lcd();
}

// Генератора для Samsung или Xerox где надо сменить 2 номерa 
// Младший разряд находится в 63 байте и в 191
// ...
void change_crum_two_xerox()
{
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize();

  int temp_sn_one = 63;
  int temp_sn_two = 191;
  for (int i = 5; i > 0; i--) // меняем 5 последних разрядов серийника
  {
    int randomNum = random(48, 57); // ANSI (48-58) а в DEC (0-9)
    eeprom.writeByte(temp_sn_one, randomNum); // Записываем значение в адрес
    delay(10); // пауза для записи в ячейку EEPROM
    eeprom.writeByte(temp_sn_two, randomNum); // Записываем значение в адрес
    delay(10); // пауза для записи в ячейку EEPROM
    temp_sn_one--; // переход к старшему разряду
    temp_sn_two--; // переход к старшему разряду
  }
  
  Serial.println(F("CHANGE CRUM 1-2 END"));
  
  // Показываем серийный номер на lcd
  print_sn_on_lcd();
}

// Генератора для Ricoh где надо сменить 1 номер
// Младший разряд находится в 23 байте
// ...
void change_crum_ricoh()
{
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize(); 
   
  int temp_sn_one = 23; // Получаем номер байта серийника
  for (int i = 2; i > 0; i--) // меняем 2 младших разрядов серийника
  {   
   int randomNum = random(48, 57); // ANSI (48-58) а в DEC (0-9)
   eeprom.writeByte(temp_sn_one, randomNum); // Записываем значение в адрес
   delay(10); // пауза для записи в ячейку EEPROM 
   temp_sn_one--; // переход к старшему разряду
   Serial.println(randomNum);
  }
  Serial.println(F("CHANGE CRUM END")); 
}

/************************************* ВЫВОД СЕРИЙНОГО НОМЕРА НА LCD *************************************/
void print_sn_on_lcd()
{  
  Eeprom24C04_16 eeprom(address_eeprom); 
  eeprom.initialize(); 

  lcd.clear();
  lcd.print(F("SERIAL NUMBER"));
  lcd.setCursor(0,1);
  lcd.print(F("CRUM-"));
  lcd.setCursor(5,1);
  //
  Serial.println(F("SERIAL NUMBER")); 
  Serial.print(F("CRUM-")); 
  //
  int global_number_byte_end_of_sn = 63;
  int temp_start = global_number_byte_end_of_sn - 10;
  int temp_end = global_number_byte_end_of_sn + 1;
  for(int i = temp_start; i < temp_end; i++)
  {
    char c = (char)eeprom.readByte(i); // получаем ascii из hex 
    lcd.print(c);
    Serial.print(c);
  }
  Serial.println(" ");
  // Задержка для просмотра номера
  delay(1000);
}

/************************************* ПОКАЗ ДАМПА НА LCD *************************************/

void read_chip_and_display_it()
{
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize(); 

  //char c = (char)eeprom.readByte(0); // получил hex to ascii
  int byte_in_str = 16;
  //int sizeof_chip = 256;  // Показываем 16 строк
  //int sizeof_chip = 128;  // Показываем 8 строк
  //int sizeof_chip = 96; // Показываем 6 строк
  int sizeof_chip = global_size_dump;
  int num_str_in_chip = sizeof_chip / byte_in_str;

  for(int i_1 = 0; i_1 < num_str_in_chip; i_1++)
  {
      lcd.clear();
      lcd.print(F("STRING # "));
      lcd.print(i_1);
      for (int i_2 = 0; i_2 < 17; i_2++)
      {
        lcd.setCursor(i_2,1);
        char a = (char)eeprom.readByte(i_2 + i_1 * byte_in_str); // Получаем ascii
        char b; // 
        if (a < 32){ b = 32; } // если a 0 то ставим пробел HEX(32)
        else{ b = a; }
        lcd.print(b); // 15 31 47 63 79 95 111 127
        //lcd.setCursor(i_2,0);
        //Serial.println(eeprom.readByte(i_2 + i_1 * byte_in_str));
      }
      delay(500);
  }
  lcd.clear();
  /*
  for (int i=0; i < 128; i++)
  {
    char a = (char)eeprom.readByte(i); // Получаем ascii
    char b; // 
    if (a < 32){ b = 32; } // если a 0 то ставим пробел HEX(32)
    else{ b = a; }
    //lcd.print(b); // 15 31 47 63 79 95 111 127
    //lcd.setCursor(i,0);
    Serial.println(eeprom.readByte(i));
  }
  */

  // Показываем текущий чип на экране
  set_global_variables(global_id); 
}

/************************************* ПОКАЗ ДАМПА В МОНИТОРЕ ПОРТА *************************************/
void extract_dump(int sizeof_chip)
{ 
  // Включаем питание
  power_on_for_chip();
  
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize();
  
  //int sizeof_chip = capacity_chip;  // Количество байт в чипе
  int num_str_in_chip = sizeof_chip / 16; // Количство строк в чипе

  Serial.println(F("Чтение дампа из чипа:"));
  for (int count_str = 0; count_str < num_str_in_chip;  count_str++)
  {
    for (int i = 0; i < 16 ; i++)
    {  
      unsigned char letter = (unsigned char)eeprom.readByte(i + count_str * 16); // Получаем байт из чипа
      if (letter < 16){ Serial.print(F("0")); } // Если это число меньше 16 то добавляем 0 спереди
      Serial.print(letter, HEX); 
      Serial.print(F(" "));
    }
    Serial.println(F("")); // Переход на новую строку
  }

  // Включаем питание
  power_off_for_chip();

  // Показываем текущий чип на экране
  set_global_variables(global_id);
}
/************************************* ПРОВЕРКА КОНТАКТА НА ЧИПЕ *************************************/
void check_contact()
{
  // По умолчанию считается что контакта с чипом нет (если все хорошо то этого сообщения не увидите)
  lcd.clear(); lcd.print(F("CONTACT CHIP"));  lcd.setCursor(0,1); lcd.print(F("BAD"));
  byte address = 1;
  byte error = 0;
  for(address = 1 ; address < 127; address++ )
  {        
    Wire.beginTransmission(address);
    error = Wire.endTransmission();
    if (error == 0)
    {
      //Serial.println(F("Contact GOOD"));
      lcd.setCursor(0,1);
      lcd.print(F("GOOD"));
      break;
    }
  }
  delay(1000);
  // Показываем текущий чип на экране
  set_global_variables(global_id);
}

/************************************* ПРОШИВКА ЧИПА С ТАЙМЕРОМ *************************************/
void firmware_chip_with_timer(int timer)
{
  // Таймер обратного отсчета
  countdown_timer(timer);
      
  // Подаем питание и сканируем шину i2c на наличие чипа
  power_on_for_chip();
      
  //Скоростная прошивка чипа
  if(global_size_dump <= 256)
  {
    firmware_24c01_02();
  }
  else
  {
    firmware_24c04_16();
  }
     
  // Выключаем питание
  power_off_for_chip();  

  // Возврат в меню
  set_global_variables(global_id);
}
/************************************* ТАЙМЕР ОБРАТНОГО ОТСЧЕТА *************************************/
void countdown_timer(int timer)
{
  //int timer = 8; // Время которое ждем перед прошивкой чипа
  lcd.clear(); 
  lcd.print(F("COUNTDOWN TIMER"));
  for(int i = timer; i > 0; i--)
  {
    lcd.setCursor(0,1);
    lcd.print(i); 
    delay(1000); // Задержка в 1 сек перед повтором цикла
  }
}

/************************************* ПОКАЗ ОТПЕЧАТАННЫХ СТРАНИЦ ДЛЯ RICOH *************************************/
void total_pages_on_display_ricoh()
{
  // Включаем питание
  power_on_for_chip();
  
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize(); 

  lcd.clear();
  lcd.print(F("TOTAL PAGE"));
  lcd.setCursor(0,1);
    
  byte HigherByte = eeprom.readByte(65); // Считываем 65 байт это старшый разряд
  byte LowerByte = eeprom.readByte(64); // Считываем 64 байт это младший разряд
  int Result = (HigherByte << 8) | LowerByte; // соединяем 2 разряда в одно
  
  lcd.print(Result); // показываем число на экран
  
  //delay(5000); // 5 секунд

  //lcd.clear();

  // Включаем питание
  power_off_for_chip();

  // Показываем текущий чип на экране
  // database(global_id); 
}

/************************************* ОТЛАДКА *************************************/

/************************************* Узнаем сколько во время работы осталось RAM ******************************/
/*
//Использование
//Serial.println(memoryFree());

// Переменные, создаваемые процессом сборки,
// когда компилируется скетч
extern int __bss_end;
extern void *__brkval;
 
// Функция, возвращающая количество свободного ОЗУ (RAM)
int memoryFree()
{
   int freeValue;
   if((int)__brkval == 0)
      freeValue = ((int)&freeValue) - ((int)&__bss_end);
   else
      freeValue = ((int)&freeValue) - ((int)__brkval);
   return freeValue;
}

*/
/*
  { "RICOH 2K", "GVCD", "SP 100 (SP 101E)", dump_ricoh_sp_101e_407059, sizeof(dump_ricoh_sp_101e_407059), 0 },
  { "RICOH 2.6K", "GVCD", "SP 111 (SP 110E)", dump_ricoh_sp_110e_407441, sizeof(dump_ricoh_sp_110e_407441), 0 },
  { "RICOH 1.5K", "GVCD", "SP 150", dump_ricoh_sp_150_408010, sizeof(dump_ricoh_sp_150_408010), 0 },
  { "RICOH 2.6K", "GVCD", "200/02/03/10/12", dump_ricoh_sp_200_hl_407262, sizeof(dump_ricoh_sp_200_hl_407262), 0 },
  { "RICOH 2.6K", "GVCD", "201/04/11/13/20", dump_ricoh_sp_201_hl_111135, sizeof(dump_ricoh_sp_201_hl_111135), 0 },
  { "RICOH 2K", "GVDC", "C220-222 240 B", dump_ricoh_sp_c220_221_222_240_406144_black, sizeof(dump_ricoh_sp_c220_221_222_240_406144_black), 0 },
  { "RICOH 2K", "GVDC", "C220-222 240 C", dump_ricoh_sp_c220_221_222_240_406145_cyan, sizeof(dump_ricoh_sp_c220_221_222_240_406145_cyan), 0 },
  { "RICOH 2K", "GVDC", "C220-222 240 M", dump_ricoh_sp_c220_221_222_240_406146_magenta, sizeof(dump_ricoh_sp_c220_221_222_240_406146_magenta), 0 },
  { "RICOH 2K", "GVDC", "C220-222 240 Y", dump_ricoh_sp_c220_221_222_240_406147_yellow, sizeof(dump_ricoh_sp_c220_221_222_240_406147_yellow), 0 },
  { "RICOH 2K", "GVDC", "SP 250/260 B", dump_ricoh_sp_c250_c260_407543_black, sizeof(dump_ricoh_sp_c250_c260_407543_black), 0 },
  { "RICOH 2K", "GVDC", "SP 250/260 M", dump_ricoh_sp_c250_c260_407545_magenta, sizeof(dump_ricoh_sp_c250_c260_407545_magenta), 0 },
  { "RICOH 2K", "GVDC", "SP 250/260 Y", dump_ricoh_sp_c250_c260_407546_yellow, sizeof(dump_ricoh_sp_c250_c260_407546_yellow), 0 },
  { "RICOH 2K", "GVDC", "SP 250/260 C", dump_ricoh_sp_c250_c260_407544_cyan, sizeof(dump_ricoh_sp_c250_c260_407544_cyan), 0 },
  { "RICOH 6.5K", "GVDC", "SP 252 B", dump_ricoh_sp_c252_407716_black, sizeof(dump_ricoh_sp_c252_407716_black), 0 },
  { "RICOH 6K", "GVDC", "SP 252 C", dump_ricoh_sp_c252_407717_cyan, sizeof(dump_ricoh_sp_c252_407717_cyan),0 },
  { "RICOH 6K", "GVDC", "SP 252 M", dump_ricoh_sp_c252_407718_magenta, sizeof(dump_ricoh_sp_c252_407718_magenta), 0 },
  { "RICOH 6K", "GVDC", "SP 252 Y", dump_ricoh_sp_c252_407719_yellow, sizeof(dump_ricoh_sp_c252_407719_yellow), 0 },
  { "RICOH 2.6K", "GVCD", "SP 277", dump_ricoh_sp_277_408160, sizeof(dump_ricoh_sp_277_408160), 0 },
  { "RICOH 1.5K", "GVDC", "SP 300", dump_ricoh_sp_300_406956, sizeof(dump_ricoh_sp_300_406956), 0 },
  { "RICOH 6K", "GVDC", "SP 310 B", dump_ricoh_sp_310_406479_black, sizeof(dump_ricoh_sp_310_406479_black), 0 },
  { "RICOH 6K", "GVDC", "SP 310 Y", dump_ricoh_sp_310_406482_yellow, sizeof(dump_ricoh_sp_310_406482_yellow), 0 },
  { "RICOH 6K", "GVDC", "SP 310 M", dump_ricoh_sp_310_122728_magenta, sizeof(dump_ricoh_sp_310_122728_magenta), 0 },
  { "RICOH 6K", "GVDC", "SP 310 C", dump_ricoh_sp_310_122700_cyan, sizeof(dump_ricoh_sp_310_122700_cyan), 0 },
  { "RICOH 3.5K", "GVCD", "SP 311/325", dump_ricoh_sp_311_407246, sizeof(dump_ricoh_sp_311_407246), 0 },
  { "RICOH 6.4K", "GVCD", "SP 311/325", dump_ricoh_sp_311_821242, sizeof(dump_ricoh_sp_311_821242), 0 },
  { "RICOH 7K", "GVCD", "SP 330", dump_ricoh_sp_330_408283, sizeof(dump_ricoh_sp_330_408283), 0 },
  { "RICOH 5K", "GVCD", "SP 400/450", dump_ricoh_sp_400_450, sizeof(dump_ricoh_sp_400_450), 0 },
  { "RICOH 5K", "GVDC", "3400/10 3500/10", dump_ricoh_sp_3400he_406522, sizeof(dump_ricoh_sp_3400he_406522), 0 },
  { "RICOH 6.4K", "GVDC", "ONLY 3500/10", dump_ricoh_sp_3500xe_406990, sizeof(dump_ricoh_sp_3500xe_406990), 0 },
  { "RICOH 12K", "GVCD", "SP 3600/10 4510", dump_ricoh_sp_4500he_407318, sizeof(dump_ricoh_sp_4500he_407318), 3 },      // 3 функция с 23 начало
  { "SAMSUNG 3K", "VDCG", "SCX 4200/20", dump_samsung_scx_d4200a, sizeof(dump_samsung_scx_d4200a), 1 },                 // 1 функция с 63 начало
  { "XEROX 2K", "VDCG", "PE 220", dump_xerox_013R00621, sizeof(dump_xerox_013R00621), 1 },                              // 1 функция с 63 начало
  { "XEROX 3K", "VDCG", "WC 3119", dump_xerox_013R00625, sizeof(dump_xerox_013R00625), 1 },                             // 1 функция с 63 начало
  { "XEROX 8K", "GCDV", "WC 4118", dump_xerox_006R01278, sizeof(dump_xerox_006R01278), 2 },                             // 2 функция с 63 начало и 191
  { "RICOH 5K", "GVDC", "SP 360 Y", dump_ricoh_sp_360_408179_yellow, sizeof(dump_ricoh_sp_360_408179_yellow), 0 },
  { "RICOH 5K", "GVDC", "SP 360 M", dump_ricoh_sp_360_408178_magenta, sizeof(dump_ricoh_sp_360_408178_magenta), 0 },
  { "RICOH 5K", "GVDC", "SP 360 C", dump_ricoh_sp_360_408177_cyan, sizeof(dump_ricoh_sp_360_408177_cyan), 0 }           // Последняя строка без запятой !!!
  */
