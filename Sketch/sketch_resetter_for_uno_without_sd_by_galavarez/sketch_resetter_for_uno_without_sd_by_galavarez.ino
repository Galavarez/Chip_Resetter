/* 
Auto Resetter wthiout sd card by Galavarez
* Версия 03.11.2017 11:17
- Добавил чип Xerox PE 220

* Версия 13.10.2017 14:36
- Добавил проверку на запись дампа в чип 

* Версия 12.10.2017 12:37
- Добавил задержку при подачи питания для стабильности
- Вернул обработку нажатий кнопок для DOWN и SELECT 

* Версия 06.10.2017 19:17
- Добавил чип Ricoh SP 100 (SP 101E)
- Добавил чип Ricoh SP 111 (SP 110E)
- Добавил чип Ricoh SP 150
- Добавил чип Ricoh SP 300
- Добавил чип Ricoh SP 311
- Добавил чип Samsung SCX 4200 (автоматическая смена номера CRUM)
- Добавил чип Xerox WC 3119 (автоматическая смена номера CRUM)
*/

// Подключаем библиотеку которая позволяет управлять микросхемами 24CXX подключать их на ПИН A4 (SDA), A5 (SCL)
#include <Eeprom24C04_16.h> 
// Подключаем библиотеку которая позволяет взаимодействовать с различными устройствами по интерфейсу I2C / TWI.
#include <Wire.h> 
// Подключаем библиотеку которая позволяет управлять различными жидкокристаллическими дисплеями (LCD)
#include <LiquidCrystal.h>  
// Подключаем библиотеку для записи статических строк во FLASH а не в RAM 
// Serial.print(F(Тут_статическая_строка)) или const PROGMEM до вызова SETUP
// Serial.println(pgm_read_byte(&dump_ricoh_sp_150[i]), HEX); чтение переменной без изменений из FLASH
#include <avr/pgmspace.h>

// Пины LCD 1602 (RS, E, D4, D5, D6, D7)
LiquidCrystal lcd( 8, 9, 4, 5, 6, 7 );

// Пин питания у Вас может быть другой
#define POWER_PIN A2

// Адрес на котором сидит чип, он динамический, меняется от чипа к чипу
// Переменная для хранения адреса чипа
byte address_eeprom;

// Храним номер чипа
byte global_id = 1;

// Переменная для запоминания состояние кнопки, защита от повторного срабатывания
boolean global_button_press = false; // true - кнопка нажата

/****************************** ДАМПЫ ЧИПОВ ******************************/
// SP150HE (408010) 1.5k от Aficio SP 150 (W/SU/SUW) 24С01
const PROGMEM byte dump_ricoh_aficio_sp_150[128] = 
{
  0x32, 0x00, 0x01, 0x03, 0x02, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x38, 0x30, 0x31, 0x30, 
  0x16, 0x10, 0x4D, 0x4D, 0x26, 0x00, 0x01, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// SCX-4200 3k от Samsung SCX-4200/4220 24С04
const PROGMEM byte dump_samsung_scx_4200[512] = {
  0x43, 0x34, 0x32, 0x30, 0x30, 0x45, 0x58, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x30, 0x36, 0x30, 0x32, 0x00, 0x00, 
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x30, 0x36, 0x30, 0x32, 0x32, 0x31, 0x33, 0x32, 0x36, 0x33, 0x32, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x34, 0x32, 0x30, 0x30, 0x45, 0x58, 0x50, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xDD, 0x00, 0x22, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x43, 0x72, 0x75, 0x6D, 0x20, 0x42, 0x79, 0x20, 
  0x48, 0x77, 0x61, 0x6E, 0x67, 0x2E, 0x73, 0x6B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// SP300 (406956) 1.5k от Aficio SP 300DN 24С01
const PROGMEM byte dump_ricoh_aficio_sp_300[128] = {
  0x13, 0x00, 0x01, 0x03, 0x03, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x39, 0x35, 0x36, 0x11, 0x11, 0x4A, 0x4D, 0x51, 0x00, 0x19, 0x76,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// XEROX WC 3119 24С04
const PROGMEM byte dump_xerox_wc_3119[512] = {
  0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x30, 0x36, 0x30, 0x36, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x30, 0x36, 0x30, 0x36, 0x32, 0x39, 0x30,
  0x39, 0x33, 0x31, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xCC, 0xDD, 0x00, 0x22, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0x43, 0x72, 0x75, 0x6D, 0x20, 0x42, 0x79, 0x20,
  0x48, 0x77, 0x61, 0x6E, 0x67, 0x2E, 0x73, 0x6B, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// RICOH SP101E (407059) от Aficio SP 100 (SF/SU/E)
const PROGMEM byte dump_ricoh_aficio_sp_101e_sp_100[128] = {
  0x20, 0x00, 0x01, 0x03, 0x03, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x39, 0x34, 0x37, 0x12, 0x04, 0x4D, 0x41, 0x16, 0x00, 0x08, 0x04,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

//RICOH AFICIO SP 111 SF/SU CARTRIDGE SP 110E
const PROGMEM byte dump_ricoh_aficio_sp_110e_sp_111[128] = {
  0x20, 0x00, 0x01, 0x05, 0x01, 0x01, 0x03, 0x00, 0x64, 0x00, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0x14, 0x05, 0x4D, 0x47, 0x21, 0x00, 0x08, 0x52,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x64, 0x30, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0xB9, 0x00, 0x00, 0x64, 0x02,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// SP 311 (407246) 3.5K 
const PROGMEM byte dump_ricoh_aficio_sp_311[128] = {
  0x07, 0x00, 0x01, 0x03, 0x07, 0x01, 0x01, 0x00, 0x00, 0x00, 0x34, 0x30,
  0x37, 0x32, 0x34, 0x36, 0x13, 0x00, 0x47, 0x00, 0x04, 0x00, 0x01, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x58, 0x12, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// XEROX PE 220 2k
const PROGMEM byte dump_xerox_pe_220[256] = {
  0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x30, 0x36, 0x30, 0x34, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x30, 0x36, 0x30, 0x34, 0x30, 0x36, 0x33,
  0x33, 0x35, 0x38, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF
};
/****************************** SETUP ******************************/

void setup() 
{
  lcd.begin(16, 2);  // Инициализируем LCD 16x2
  Serial.begin(9600); //инициализируем последовательное соединение для работы с ПК
  while (!Serial) { ; } // Ждем когда подключится ардуино к пк по usb
  Wire.begin(); //инициализируем библиотеку I2C / TWI для работы с I2C устройствами
 
  // Пин А2 для питания чипа устанавливаем в положение OUTPUT
  // Пин A0-14 A1-15 A2-16 A3-17 A4-18 A5-19
  pinMode(POWER_PIN, OUTPUT);

  // Показываем первый чип на экране
  db_name(global_id);
}

/****************************** LOOP ******************************/

void loop() 
{
  /* ОБРАБОТКА НАЖАТИЯ КНОПОК */

  // Задаем номер порта с которого производим считывание
  int analog_number = analogRead(0); 
  //Serial.println(analog_number);

  if (analog_number < 100 && global_button_press == false) // Если это кнопка Right и другие кнопки не нажаты то
  {
    if (analog_debonce(100) == true) // делаем проверку от дребезга кнопок
    {
       Serial.println(F("CLICK BUTTON RIGHT"));
      // Увеличиваем счтчки
      global_id++;
      // Показываем на экране
      db_name(global_id);
    }
  }
  else if (analog_number < 200 && global_button_press == false) // Если это кнопка UP и другие кнопки не нажаты то
  {
    if (analog_debonce(200) == true) // делаем проверку от дребезга кнопок
    {
       Serial.println(F("CLICK BUTTON UP")); // UPLOAD -- закачиваем дамп
      // Подаем питание и сканируем шину i2c на наличие чипа
      power_on_for_chip();
            
      lcd.clear();
      lcd.print(F("FIRMWARE CHIP"));
      lcd.setCursor(0, 1);      
      lcd.blink(); // влючаем мигание курсора для информативности
      
      // Прошивка чипа
      db_firmware(global_id);

      lcd.print(F("DONE !!!"));
      lcd.noBlink(); // отключаем мигание курсора

      // Тест данных
      test_chip(128);
      
      // Выключаем питание
      power_off_for_chip();

      // Возврат в меню
      db_name(global_id);
    }
  }
  else if (analog_number < 400 && global_button_press == false) // Если это кнопка Down и другие кнопки не нажаты то
  {
    if (analog_debonce(400) == true) // делаем проверку от дребезга кнопок
    {
      Serial.println(F("CLICK BUTTON DOWN"));
    }
  }
  else if (analog_number < 600 && global_button_press == false) // Если это кнопка Left и другие кнопки не нажаты то
  {
    if (analog_debonce(600) == true) // делаем проверку от дребезга кнопок
    {
       Serial.println(F("CLICK BUTTON LEFT"));
      // Уменьшаем счетчик 
      global_id--; 
      // Показываем на экране
      db_name(global_id);
    }
  }
  else if (analog_number < 800 && global_button_press == false) // Если это кнопка Select и другие кнопки не нажаты то
  {
    if (analog_debonce(800) == true)  // делаем проверку от дребезга кнопок
    {
      Serial.println(F("CLICK BUTTON SELECT")); 
    }
  }

  // Обнуляем переменную globalBntPress если все кнопки отпущены
  if ( analogRead(0) > 1000)  {
    global_button_press = false;
  }
}

/****************************** БАЗА ДАННЫХ ******************************/

void db_name(byte id)
{
  switch (id)
  {    
    case 1:
      lcd.clear();
      lcd.print(F("RICOH"));
      lcd.setCursor(0,1);
      lcd.print(F("SP 100 (SP 101E)"));
      break;
    case 2:
      lcd.clear();
      lcd.print(F("RICOH"));
      lcd.setCursor(0,1);
      lcd.print(F("SP 111 (SP 110E)"));
      break;      
    case 3:
      lcd.clear();
      lcd.print(F("RICOH"));
      lcd.setCursor(0,1);
      lcd.print(F("SP 150"));
      break;
    case 4:
      lcd.clear();
      lcd.print(F("RICOH"));
      lcd.setCursor(0,1);
      lcd.print(F("SP 300"));
      break;
    case 5:
      lcd.clear();
      lcd.print(F("RICOH"));
      lcd.setCursor(0,1);
      lcd.print(F("SP 311"));
      break;
    case 6:
      lcd.clear();
      lcd.print(F("SAMSUNG"));
      lcd.setCursor(0,1);
      lcd.print(F("SCX 4200"));
      break;
    case 7:
      lcd.clear();
      lcd.print(F("XEROX"));
      lcd.setCursor(0,1);
      lcd.print(F("WC 3119"));
      break;
    case 8:
      lcd.clear();
      lcd.print(F("XEROX"));
      lcd.setCursor(0,1);
      lcd.print(F("PE 220"));
      break;
    default:
      // Если номер нет в базе то переходим к 1 чипу
      global_id = 1;
      db_name(global_id);
  }    
}

void db_firmware(byte id)
{
  switch (id)
  {
    case 1:
      // Прошиваем чип => указываем переменную и ее размер 
      firmware(dump_ricoh_aficio_sp_101e_sp_100, sizeof(dump_ricoh_aficio_sp_101e_sp_100));
      break;
    case 2:
      firmware(dump_ricoh_aficio_sp_110e_sp_111, sizeof(dump_ricoh_aficio_sp_110e_sp_111));
      break;      
    case 3: 
      firmware(dump_ricoh_aficio_sp_150, sizeof(dump_ricoh_aficio_sp_150));
      break;
    case 4:
      firmware(dump_ricoh_aficio_sp_300, sizeof(dump_ricoh_aficio_sp_300));
      break;     
    case 5:
      firmware(dump_ricoh_aficio_sp_311, sizeof(dump_ricoh_aficio_sp_311));
      break;
    case 6:
      firmware(dump_samsung_scx_4200, sizeof(dump_samsung_scx_4200));      
      change_crum_one(63); // Указываем номер байта младшего разряда серийного номера 
      break;
    case 7:
      firmware(dump_xerox_wc_3119, sizeof(dump_xerox_wc_3119));      
      change_crum_one(63);  
      break;
    case 8:
      firmware(dump_xerox_pe_220, sizeof(dump_xerox_pe_220));      
      change_crum_one(63); 
      break;
  }
}


/****************************** ЗАЩИТА ОТ ДРЕБЕЗГА КНОПОК И ПОВТОРНЫХ НАЖАТИЙ ******************************/

boolean analog_debonce(int max_value)
{
  delay(50); // Пауза перед повторным считыванием кнопки
  if ( analogRead(0) < max_value) // Если все еще держим кнопку а не случайный дребезг то
  {
    global_button_press = true; // Запоминаем что нажали кнопку
    return true; // Проверка на дребегз пройдена
  }
  else
  {
    return false; // Проверка на дребегз НЕ пройдена
  }
}

/****************************** ВКЛЮЧАЕМ ПИТАНИЯ ЧИПА ******************************/

void power_on_for_chip()
{
  digitalWrite(POWER_PIN, HIGH); // Подаем питания на A2 для запитки чипа
  delay(500); // Задержка для поднятия напряжения
  search_address_chip(); // Сканируем шину I2C на наличия чипа и сохраняем адрес его в памяти
}

/****************************** ВЫКЛЮЧАЕМ ПИТАНИЯ ЧИПА ******************************/
void power_off_for_chip()
{
  digitalWrite(POWER_PIN, LOW); // Выключаем питания на A2 пине
}

/****************************** ПОИСК ЧИПА НА ШИНЕ I2C ******************************/
void search_address_chip()
{
  byte error, address;
  for(address = 1; address < 127; address++ )
  {        
    Wire.beginTransmission(address);
    error = Wire.endTransmission();
    if (error == 0) // Ошибок нет, устройство найдено
    {     
      Eeprom24C04_16 eeprom(address); // Берем адреес шины и пытаемся считать данные с чипа
      eeprom.initialize();
      if (eeprom.readByte(0) != 0xFF) // Считываем нулевой байт, если он 0xFF то ищим следующий адрес 
      {
        address_eeprom = address; // Сохраняем адрес чипа в памяти
        Serial.print(F("Address chip = 0x"));
        Serial.println(address,HEX);  
        break;
      }     
    }
    else if (error==4) //Есть ошибки
    {
      Serial.println(F("error == 4"));
      Serial.println(address,HEX);
    }
  }   
}
 
/****************************** ПРОШИВКА ЧИПА ******************************/
void firmware(const byte *name_dump, int number_cycle)
{
  Serial.println(F("FIRMWARE START"));
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize();  
  for(int i = 0; i < number_cycle; i++) // Циклы
  {
    eeprom.writeByte(i, pgm_read_byte(&name_dump[i]));  
    delay(10); 

    //Serial.print(pgm_read_byte(&name_dump[i]), HEX);
    //Serial.print(F(" = "));
    //Serial.println(eeprom.readByte(i), HEX);
    
    // Проверка данных на запись, если они не равны показываем ошибку
    if(pgm_read_byte(&name_dump[i]) != eeprom.readByte(i))
    {
      lcd.clear();
      lcd.print(F("ERROR"));
      lcd.setCursor(0,1);
      lcd.print(F("WRITE DUMP"));
      Serial.print(F("ERROR WRITE DUMP"));
      break;      
    }
    //Serial.print(F("number byte = "));
    //Serial.print(i);
    //Serial.print(F(" value byte = "));
    //Serial.print(pgm_read_byte(&name_dump[i]), HEX);
    //Serial.print(F(" eeprom read byte = "));
    //Serial.println(eeprom.readByte(i), HEX);
  }
  Serial.println(F("FIRMWARE END"));
}

/****************************** ГЕНЕРАТОР СЕРИЙНОГО НОМЕРА ******************************/
void change_crum_one(int address_low_byte_sn)
{  
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize();  
   
  int temp_sn_one = address_low_byte_sn; // Получаем номер байта серийника
  for (int i = 6; i > 0; i--) // меняем 6 младших разрядов серийника
  {   
   int randomNum = random(48, 57); // ANSI (48-58) а в DEC (0-9)
   eeprom.writeByte(temp_sn_one, randomNum); // Записываем значение в адрес
   delay(10); // пауза для записи в ячейку EEPROM
   //Serial.print("num byte = ");
   //Serial.print(temp_sn_one);
   //Serial.print(" value = ");
   //Serial.println(asciiToInt(randomNum));  
   temp_sn_one--; // переход к старшему разряду
  }
  //Serial.println(" ");
  Serial.println(F("CHANGE CRUM END"));
  // Показать крум
  //crum_print(53,64);
}

void change_crum_two(int address_low_byte_sn_1, int address_low_byte_sn_2)
{
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize();
  int temp_sn_one = address_low_byte_sn_1;
  int temp_sn_two = address_low_byte_sn_2;
  for (int i = 5; i > 0; i--) // меняем 5 последних разрядов серийника
  {
    int randomNum = random(48, 57); // ANSI (48-58) а в DEC (0-9)
    eeprom.writeByte(temp_sn_one, randomNum); // Записываем значение в адрес
    delay(10); // пауза для записи в ячейку EEPROM
    eeprom.writeByte(temp_sn_two, randomNum); // Записываем значение в адрес
    delay(10); // пауза для записи в ячейку EEPROM
    temp_sn_one--; // переход к старшему разряду
    temp_sn_two--; // переход к старшему разряду
  }
  // выводим на экран сгенерированный серийный номер
  //print_crum();
}

/************************************* ОТЛАДКА *************************************/
/* Перевод цифр из ASCII в DEC */
int asciiToInt(int num)
{
  switch(num)
  {
    case 48:      // ASCII 48 в DEC 0
      return 0;
      break;
    case 49:      // ASCII 49 в DEC 1
      return 1;
      break;
    case 50:
      return 2;
      break;
    case 51:
      return 3;
      break;
    case 52:
      return 4;
      break;
    case 53:
      return 5;
      break;
    case 54:
      return 6;
      break;
    case 55:
      return 7;
      break;
    case 56:
      return 8;
      break;
    case 57:
      return 9;
      break;
  }
}

void crum_print(int num_start, int num_end)
{
  
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize();
  Serial.print("CRUM-"); 
  for(int i = num_start; i < num_end; i++)
  {
    Serial.print(asciiToInt(eeprom.readByte(i)));
  }
  Serial.println(" ");
}
String insert_null(byte num)
{
  // Подставляем ноль если число меньше 10
  if (num < 0x10) {Serial.print("0");} Serial.print(num,HEX);  
}


void test_chip(int number_cycle)
{
  Eeprom24C04_16 eeprom(address_eeprom);
  eeprom.initialize(); 
  Serial.println(F("00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F"));
  Serial.println(F(" "));
  for (int i = 0; i < number_cycle; i++)
  {
   if ( i%16 == 0 && i!=0)
   {
     Serial.println(" ");
     insert_null(eeprom.readByte(i)); 
     Serial.print(" ");         
   }
   else
   {
    insert_null(eeprom.readByte(i)); 
    Serial.print(" ");
   }   
  }
  Serial.println(" ");
}
