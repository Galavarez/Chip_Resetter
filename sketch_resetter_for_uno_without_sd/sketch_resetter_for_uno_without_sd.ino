/*  
Auto Resetter wthiout sd card by Galavarez
* Версия 10.07.2024
- Добавил дамп от Катюши TK240А был до этого только TK240Х

* Версия 19.05.2024
- Переписал поиск чипа чтобы Resetter работать с чипами для принтера катюша а это чипы GT24C02-2GLI-TR 402-2GLI 402-2GL1 FA5522N-A2-TE1 FA5522 MC5522 5522.
- Добавил дамп чипов катюша TK240 (картридж) и DR240 (драм) а так же написал авто генератор crum`a для них, фотки чипов и их распиновок в папке Photos of the chip 
- Добавил дамп чипа Ricoh SP 4500/4510/3600/3610 на 6K, до этого был только на 12К
- Добавил перекалибровку кнопок через пятикратный перезапуск Resetter через кнопку RESET
- Переписал смену crum`a номера и его вывод на LCD на более универсальный
- Переписал "быструю прошивку чипа" т.к. оперативки становится меньше и ардуино не справляется
- Таймер сна поставил по умолчанию 4 минуты

* Версия 01.04.2023
- Появилась возможность обнулять чип  416RT это аналог AT24C16. 
Данный чип используется в абсорбере MC-G02 для принтеров Canon PIXMA G1420, G2420, G2460, G3420, G3460, G640 и G540. 
Идею и дамп чипа подкинул Maksim Zubcov за это ему большое спасибо. 
Обнуление чипа длится около 20-30 сек. Фото схемы подключения находится в папке Photos of the chip.
- Добавил так же чтение дампа (2048 байт) как раз такой емкости стоит чип в абсорбере MC-G02.

* Версия 20.05.2022
- Поменял название PRESS и NOT PRESS на более понятные HOLD DOWN (удерживать кнопку) и PUSH OUT BUTTON (отпустить кнопку) при автонастройке обнулятора.

* Версия 25.01.2022
- Добавил автонастройку кнопок (давно надо было это сделать). При включение обнулятор попроси нажать, а потом отпустить кнопки по очередно, а потом нажать reset. 
Все значения сохранит у себя в памяти и больше не будет вас этим тревожить. Значения хранятся даже если перезалить скетч.
Если надо сделать перекалибровку кнопок то через доп программу Calibration keypad shield можно это сделать.
Стереть значения можно через доп программу "Calibration keypad shield" или в ручную раскоментировав (а потом закоментировать) функцияю clear_value_button() в setup
- Как я выяснил в ардуино uno разработчики платы предусмотрели на контактах DATA CLK свои внутренние резисторы, поэтому схема сборки еще упрощается =) 
Выкидываем резисторы и без них все прекрасно работает.

* Версия 16.12.2021
- Добавил авто отключения ардуино после 30 секунд бездействия, время можно увеличить в функции time_to_sleep().
Не забудьте выпаять светодиоды или резисторы (на ардуино uno => R17, R6, R7, R16 и на lcd keypad shield => R1 ) чтобы увеличить в автономный режим. 
Со светодиодами ардуина кушает 15-17 mA а без них 2 mA.

* Версия 12.07.2021
- Если кнопка Select не работает (указано не верное число) в начале цикла void loop() я добавил 2 сроки, 
их надо раскоментировать и залить скетч. В мониторе порта (Serial monitor) будет показываться число нажатой кнопки.
Эти значения надо записать в BUTTON_UP....BUTTON_SELECT и снова залить скетч.Тогда все кнопки заработают как задуманно.

* Версия 02.07.2021
Очередное глобальное обновление:
- Убрал стандартную библиотеку Wire, поставил в место нее альтернативную(I2C-master). Теперь при сканирование шины с плохим контактом обнулятор
 больше не будет зависать, а сообщит о плохом контакте или отсутствия чипа (если его нет)
- Объединил 2 библиотеки (Eeprom24C01_02 и Eeprom24C04_08_16) в одну универсальную Eeprom24C01_16
- Переписал логику работы кнопок и защиты от дребезга контактов. Теперь кнопки распознают 2 состояния (короткое и долгое нажатие)
- Написал подпрограмму для калибровки кнопок для Вашего универсального lcd keypad shield. В описании на гитхабе
 распишу что, да как работает
- Переписал функцию по проверке чипа после его прошивки
- Добавил дамп SP 360 black

* Версия 17.06.2021
- Переписал код базы данных, теперь добавлять новые чипы станет легче. Надеюсь многие поймут что да как =)
- Добавил генератор серийного номера для Ricoh sp4500he 407318
- Добавил 3 дампа для Ricoh SP 360 (Правда черного цвета нет)
- Добавил дамп для Ricoh SP 377 (спасибо за него Титову Анатолию Викторовичу)

* Версия 27.01.2020
- Добавил новый дамп для Ricoh SP 360. Спасибо за ссылку Манакову Юрию

* Версия 15.11.2019
- На днях один из пользователей обнулятора (Манаков Юрий) подкинули идею о чтение дампа через обнулятор. 
Не много поразмыслив, я сделал такую возможность, но с небольшим ограничением. Можно дамп только вывести в монитор порта в ардуино ide (ctrl + shitf + M). 
Потом можно его скопировать в любой hex редактор с разрешением bin. Вот и получался дамп =)
Так же сделал несколько подпрограмм на кнопке SELECT (по любому простаивает).
Инструкция по кнопке селект:
1) Нажимаем на кнопку селект и выбираем подпрограмму (Показ отпечатанных страниц для рико, Таймер обратного отсчета с прошивкой (вернул его) и считывание дампа (128,256,512 байт)
2) Как выбрали подпрограмму (точнее остановились на ней), надо подождать 3 секунды и нажать на кнопку SELECT еще раз.
3) Все, подпрограмма выполнилаль. Надо только попрактиковаться. 
Если будут косяки пишите =)

* Версия 06.11.2019
- Добавил новый дамп для Ricoh SP 310 . Спасибо за ссылку Манакову Юрию 

* Версия 02.11.2019
- Добавил новый дамп для Ricoh SP 330SN 7k (408283). Спасибо за него Руслану Махмутову

* Версия 05.08.2019
- Добавил новый дамп для Ricoh SP 400/450 5k (408061). Спасибо за него Белобородову Михаилу

* Версия 19.07.2019
- Усреднил значения для нового и старого LCD Keypad shield v1 и v1.1. 
Кнопки должны заработать корректно сразу после заливки скетча без правки ручками. Если что в строках 162-166 можно подправить в ручную.
Так же зачения кнопок показываются в "Мониторе порта"

* Версия 03.06.2019
- Исправил значения для нового LCD Keypad shield v. 1.1. Спасибо за наблюдательность Белобородову Михаилу

* Версия 26.03.2019
- Добавил новый дамп для Ricoh Aficio SP С220 С221 С222 С240 (406144, 406145, 406146, 406147). Спасибо за него Юрию Манакову

* Версия 08.02.2019
- Исправлен дамп для Ricoh SP C250/С260 1.6K (407544) Cyan for Ricoh C250/С260. Спасибо за внимательность Белобородову Михаилу

* Версия 07.02.2019
- Добавил новый дамп для Ricoh Aficio SP C252 (407716,407717,407718,407719). Спасибо за него Белобородову Михаилу

* Версия 18.01.2019
- Добавил новый дамп для Ricoh Aficio SP C250/C260 (407543/407544/407545/407546)

* Версия 31.10.2018
- Добавил новый дамп для Ricoh Aficio SP 277 на 2.6K (408160), снят с нового чипа. Спасибо за него Дмитрию Щетневу. Мини реклама =) https://www.youtube.com/user/shetnevdima/featured

* Версия 18.10.2018
- Добавил новый дамп для Ricoh Aficio SP 277 на 2.6K (408160). Спасибо за него 1dx. Дамп надо проверить, отпишитесь по результатам проверки, работает или нет.
- Добавил функцию по проверке количества отпечатанных страниц в картриджах Ricoh. Инструкция: подключить б.у. чип и нажать кнопку SELECT (самая левая).

* Версия 11.09.2018
- Обновил дамп для Ricoh SP 110E 2.6K (407441) for Ricoh SP 111 (SF/SU). Спасибо за него Белобородову Михаилу

* Версия 10.09.2018
- Обновил дамп для Ricoh Aficio SP 200HL на 2.6K (407262). Спасибо за него Белобородову Михаилу

* Версия 09.09.2018
- Добавил новый дамп для Ricoh Aficio SP 311 UXE на 6.4K (821242). Спасибо за него Белобородову Михаилу

* Версия 03.09.2018
- Добавил новый дамп (пока тестируем) для Ricoh Aficio SP 201 series (407261). Спасибо 1dx

* Версия 20.08.2018
- Заменил дамп Xerox PE 220 на новый.

* Версия 18.04.2018
- Исправлен глюк с обнулением картриджей Richo ricoh_sp_211_213_220, ricoh_sp_211_213_220 и ricoh_sp_4510

* Версия 06.03.2018
- Для скоростной записи чипа нужны 2 разные библиотеки 24с01_02 и 24с04_16. Они в папке Library.
- Теперь обнулятор сам выбирает какой библиотекой прошивать чип, опираясь на размер дампа чипа. Если до 256 байт то 24с01_02, иначе 24с04_16.

* Версия 05.03.2018
- На кнопке SELECT будет прошивка чипа с обратным отсчетом. Это удобно когда нужно держать картридж и чип обеими руками. 
- Отсчет 8 секунд до прошивки. Время меняется в функции countdown_timer() переменная timer.

* Версия 04.03.2018
- Новая экспериментальная функция по определению плохого контакта с чипом. На экран будет выведено Concact Bad и тогда нужно будет перезапустить ардуино.
- Так же эта функция доступна по кнопке SELECT она полюбому пока не используется.

* Версия 02.03.2018
- Новая библиотека для работы с чипами, старая глючит при скоростной заливки дампа. Библиотека в папке Library.

* Версия 25.02.2018
- Не большое изменение в коде

* Версия 14.02.2018
- Добавлен круговой поиск чипов т.е. стоя на первом чипе при нажатие кнопки LEFT попадаете на последний чип
- Улучшена скорость записи чипов с 8 - 10 сек до 1 - 3 сек

* Версия 13.02.2018
- Добавил чип Ricoh SP 201HE для SP 211/213/220, принтера нет чтобы проверить прошивку.

* Версия 5.01.2018
- Не большое изменение в коде
- Добавил чип Xerox WC-4118 8k спасибо за дамп copiermaster
- Добавил чип Ricoh SP 3400 3410 (406522) 5k спасибо за дамп copiermaster
- Добавил чип Ricoh SP 3500XE (406990) 6.4k спасибо за дамп copiermaster
- Добавил чип Ricoh SP 4500HE (407318) 12k говорят что подходит к Ricoh SP 3610SF но я это не проверял

* Версия 29.12.2017 
- Переписал код для упрощения добавления новых чипов
- Исправил ошибку в генерации серийного номера
- Исправил некоторые другие ошибки

* Версия 17.12.2017 
- Добавил чип Ricoh SP 210 спасибо за дамп copiermaster

* Версия 25.11.2017 
- Добавил чип Ricoh SP 200, 202, 203 на 2.6К

* Версия 21.11.2017 
- Переписал проверку дампа после заливки его в чип
- Добавил распиновку чипа в правом верхнем углу G - gnd, V - vcc, D - data, C - clock

* Версия 14.11.2017 
- Добавил вывод дампа из чипа на экран по кнопки вниз первых 128 байт

* Версия 03.11.2017 11:17
- Добавил чип Xerox PE 220

* Версия 13.10.2017 14:36
- Добавил проверку на запись дампа в чип 

* Версия 12.10.2017 12:37
- Добавил задержку при подачи питания для стабильности
- Вернул обработку нажатий кнопок для DOWN и SELECT 

* Версия 06.10.2017 19:17
- Добавил чип Ricoh SP 100 (SP 101E)
- Добавил чип Ricoh SP 111 (SP 110E)
- Добавил чип Ricoh SP 150
- Добавил чип Ricoh SP 300
- Добавил чип Ricoh SP 311
- Добавил чип Samsung SCX 4200 (автоматическая смена номера CRUM)
- Добавил чип Xerox WC 3119 (автоматическая смена номера CRUM)
*/

/****************************** ДАМПЫ ЧИПОВ ******************************/

/*********** =====> RICOH <===== *********/

// 24С01_02 // Ricoh SP101E 2K (407059) for Ricoh SP 100 (SF/SU/E)
const PROGMEM char NOTE_SP_100[] = { "SP 100 (SP 101E)" };
const PROGMEM byte dump_ricoh_sp_101e_407059[128] = {
  0x20, 0x00, 0x01, 0x03, 0x03, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x36, 0x39, 0x34, 0x37, 
  0x12, 0x04, 0x4D, 0x41, 0x16, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 110E 2.6K (407441) for Ricoh SP 111 (SF/SU)
const PROGMEM char NOTE_SP_111[] = { "SP 111 (SP 110E)" };
const PROGMEM byte dump_ricoh_sp_110e_407441[128] = {
  0x20, 0x00, 0x01, 0x05, 0x02, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x37, 0x34, 0x34, 0x31, 
  0x17, 0x05, 0x4D, 0x43, 0x01, 0x00, 0x02, 0x51, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP150HE 1.5K (408010) for Ricoh SP 150 (SU/W/SUw)
const PROGMEM char NOTE_SP_150[] = { "SP 150" };
const PROGMEM byte dump_ricoh_sp_150_408010[128] = {
  0x32, 0x00, 0x01, 0x03, 0x01, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x38, 0x30, 0x31, 0x30, 
  0x16, 0x03, 0x4D, 0x4D, 0x04, 0x00, 0x01, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP200HL 2.6K for Ricoh SP SP200/202/203/210/212 (407262) -- новый дамп
const PROGMEM char NOTE_SP_200_202_203_210_212[] = { "200/02/03/10/12" };
const PROGMEM byte dump_ricoh_sp_200_hl_407262[128] = {
  0x21, 0x00, 0x01, 0x03, 0x02, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x37, 0x32, 0x36, 0x32,
  0x13, 0x08, 0x4D, 0x43, 0x13, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP201HE 2.6K (111135) for Ricoh SP201/204/211/213/220 
const PROGMEM char NOTE_SP_201_204_211_213_220[] = { "201/04/11/13/20" };
const PROGMEM byte dump_ricoh_sp_201_hl_111135[128] = {
  0x21, 0x00, 0x01, 0x04, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x31, 0x31, 0x31, 0x31, 0x35, 0x37, 
  0x13, 0x07, 0x4D, 0x43, 0x11, 0x00, 0x14, 0x91, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x01, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 277HE 2.6K series (408160) for Ricoh SP 277NwX / 277SNwX / 277SFNwX
const PROGMEM char NOTE_SP_277[] = { "SP 277" };
const PROGMEM byte dump_ricoh_sp_277_408160[128] = {
  0x21, 0x00, 0x01, 0x03, 0x02, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x38, 0x31, 0x36, 0x30, 
  0x16, 0x01, 0x4D, 0x43, 0x27, 0x00, 0x1F, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP300 1.5K (406956) for Ricoh SP 300DN
const PROGMEM char NOTE_SP_300[] = { "SP 300" };
const PROGMEM byte dump_ricoh_sp_300_406956[128] = {
  0x13, 0x00, 0x01, 0x03, 0x03, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x36, 0x39, 0x35, 0x36, 
  0x11, 0x11, 0x4A, 0x4D, 0x51, 0x00, 0x19, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 311HE 3.5K (407246) for Ricoh SP 311/325 (DNw/SFw/Nw)
const PROGMEM char NOTE_SP_311_325_NORMAL[] = { "SP 311/325" };
const PROGMEM byte dump_ricoh_sp_311_407246[128] = {
  0x07, 0x00, 0x01, 0x03, 0x07, 0x01, 0x01, 0x00, 0x00, 0x00, 0x34, 0x30, 0x37, 0x32, 0x34, 0x36, 
  0x13, 0x00, 0x47, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x58, 0x12, 
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 311UXE 6.4K (821242) for Ricoh SP 311/325 (DNw/SFw/Nw)
const PROGMEM char NOTE_SP_311_325_LARGE[] = { "SP 311/325" };
const PROGMEM byte dump_ricoh_sp_311_821242[128] = {
  0x07, 0x00, 0x01, 0x03, 0x0D, 0x01, 0x01, 0x00, 0x64, 0x00, 0x38, 0x32, 0x31, 0x32, 0x34, 0x32, 
  0x15, 0x10, 0x4D, 0x53, 0x22, 0x00, 0x03, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 3400HE 5K (406522) for Ricoh SP3400/3410/3500/3510
const PROGMEM char NOTE_SP_3400_3410_3500_3510[] = { "3400/10 3500/10" };
const PROGMEM byte dump_ricoh_sp_3400he_406522[128] = {
  0x07, 0x00, 0x01, 0x03, 0x03, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x36, 0x35, 0x32, 0x32, 
  0x11, 0x01, 0x4A, 0x4D, 0x02, 0x01, 0x70, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 3500XE 6.4K (406990) для Ricoh SP3500/3510 (N/DN/SF)
const PROGMEM char NOTE_SP_3500_3510[] = { "ONLY 3500/10" };
const PROGMEM byte dump_ricoh_sp_3500xe_406990[128] = {
  0x07, 0x01, 0x01, 0x03, 0x06, 0x01, 0x01, 0x00, 0x00, 0x00, 0x34, 0x30, 0x36, 0x39, 0x39, 0x30,
  0x12, 0x05, 0x4A, 0x4D, 0x53, 0x00, 0x33, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 4500HE 12K (407318) for Ricoh SP3600/3610/4510 (DN/SF) 
const PROGMEM char NOTE_SP_3600_3610_4510[] = { "SP 3600/10 4510" };
const PROGMEM byte dump_ricoh_sp_4500he_407318[128] = {
  0x23, 0x00, 0x01, 0x03, 0x78, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30, 0x37, 0x33, 0x31, 0x38, 
  0x14, 0x09, 0x54, 0x4A, 0x03, 0x00, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP 4500E 6K (407340) for Ricoh SP3600/3610/4510 (DN/SF) 
//const PROGMEM char NOTE_SP_3600_3610_4510[] = { "SP 3600/10 4510" };
const PROGMEM byte dump_ricoh_sp_4500e_407340[128] = {
  0x23, 0x00, 0x01, 0x03, 0x3C, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x37, 0x33, 0x34, 0x30, 0x14, 0x07, 0x54, 0x4A, 0x08, 0x00, 0x07, 0x55,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// 24С01_02 // Ricoh SP C250/С260 2K (407543)  Black for Ricoh C250/С260 (DN/DNW/SF/SFNW/FNW)
const PROGMEM char NOTE_SP_C250_260_B[] = { "SP 250/260 B" };
const PROGMEM byte dump_ricoh_sp_c250_c260_407543_black[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x12, 0x01, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30, 0x37, 0x35, 0x34, 0x33, 
  0x14, 0x02, 0x41, 0x42, 0x16, 0x00, 0x1B, 0x32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C250/С260 1.6K (407544) Cyan for Ricoh C250/С260 (DN/DNW/SF/SFNW/FNW)
const PROGMEM char NOTE_SP_C250_260_C[] = { "SP 250/260 C" };
const PROGMEM byte dump_ricoh_sp_c250_c260_407544_cyan[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x0E, 0x02, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30, 0x37, 0x35, 0x34, 0x34, 
  0x14, 0x02, 0x41, 0x42, 0x17, 0x00, 0x16, 0x35, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C250/С260 1.6K (407545) Magenta for Ricoh C250/С260 (DN/DNW/SF/SFNW/FNW)
const PROGMEM char NOTE_SP_C250_260_M[] = { "SP 250/260 M" };
const PROGMEM byte dump_ricoh_sp_c250_c260_407545_magenta[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x0E, 0x03, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30, 0x37, 0x35, 0x34, 0x35, 
  0x14, 0x02, 0x41, 0x42, 0x18, 0x00, 0x11, 0x39, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C250/С260 1.6K (407546) Yellow for Ricoh C250/С260 (DN/DNW/SF/SFNW/FNW)
const PROGMEM char NOTE_SP_C250_260_Y[] = { "SP 250/260 Y" };
const PROGMEM byte dump_ricoh_sp_c250_c260_407546_yellow[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x0E, 0x04, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30, 0x37, 0x35, 0x34, 0x36,
  0x14, 0x02, 0x41, 0x42, 0x19, 0x00, 0x14, 0x36, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C252 6.5K (407716) Black for Ricoh C252
const PROGMEM char NOTE_SP_C252_B[] = { "SP 252 B" }; 
const PROGMEM byte dump_ricoh_sp_c252_407716_black[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x32, 0x01, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x37, 0x37, 0x31, 0x36, 0x14, 0x01, 0x41, 0x42, 0x36, 0x00, 0x36, 0x37,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C252 6K (407717) Cyan for Ricoh C252
const PROGMEM char NOTE_SP_C252_C[] = { "SP 252 C" }; 
const PROGMEM byte dump_ricoh_sp_c252_407717_cyan[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x32, 0x02, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x37, 0x37, 0x31, 0x37, 0x14, 0x05, 0x41, 0x42, 0x37, 0x01, 0x34, 0x35,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C252 6K (407718)  Magenta for Ricoh C252
const PROGMEM char NOTE_SP_C252_M[] = { "SP 252 M" }; 
const PROGMEM byte dump_ricoh_sp_c252_407718_magenta[128] = {
 0xA8, 0x00, 0x01, 0x03, 0x32, 0x03, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
 0x37, 0x37, 0x31, 0x38, 0x14, 0x03, 0x41, 0x42, 0x38, 0x00, 0x38, 0x37,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP C252 6K (407719) Yellow for Ricoh C252
const PROGMEM char NOTE_SP_C252_Y[] = { "SP 252 Y" }; 
const PROGMEM byte dump_ricoh_sp_c252_407719_yellow[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x32, 0x04, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x37, 0x37, 0x31, 0x39, 0x14, 0x01, 0x41, 0x42, 0x39, 0x00, 0x36, 0x31,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP С220 С221 С222 С240  2k (406144) Black
const PROGMEM char NOTE_SP_C220_B[] = { "C220-222 240 B" };  
const PROGMEM byte dump_ricoh_sp_c220_221_222_240_406144_black[128] = {
  0xA7, 0x00, 0x01, 0x03, 0x14, 0x01, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x31, 0x34, 0x34, 0x09, 0x05, 0x41, 0x42, 0x62, 0x00, 0x37, 0x39,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP С220 С221 С222 С240  2k (406145) Cyan
const PROGMEM char NOTE_SP_C220_C[] = { "C220-222 240 C" };  
const PROGMEM byte dump_ricoh_sp_c220_221_222_240_406145_cyan[128] = {
  0xA7, 0x00, 0x01, 0x03, 0x14, 0x02, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x31, 0x34, 0x35, 0x09, 0x05, 0x41, 0x42, 0x63, 0x00, 0x14, 0x43,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP С220 С221 С222 С240  2k (406146) Magenta 
const PROGMEM char NOTE_SP_C220_M[] = { "C220-222 240 M" }; 
const PROGMEM byte dump_ricoh_sp_c220_221_222_240_406146_magenta[128] = {
  0xA7, 0x00, 0x01, 0x03, 0x14, 0x03, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x31, 0x34, 0x36, 0x09, 0x05, 0x41, 0x42, 0x64, 0x00, 0x22, 0x29,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP С220 С221 С222 С240  2k (406147) Yellow 
const PROGMEM char NOTE_SP_C220_Y[] = { "C220-222 240 Y" }; 
const PROGMEM byte dump_ricoh_sp_c220_221_222_240_406147_yellow[128] = {
  0xA7, 0x00, 0x01, 0x03, 0x14, 0x04, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x31, 0x34, 0x37, 0x09, 0x11, 0x41, 0x42, 0x65, 0x00, 0x07, 0x24,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP SP 400/450  5k (408061)
const PROGMEM char NOTE_SP_400_450[] = { "SP 400/450" }; 
const PROGMEM byte dump_ricoh_sp_400_450[128] = {
 0x23, 0x00, 0x01, 0x03, 0x32, 0x01, 0x30, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x38, 0x30, 0x36, 0x31, 0x16, 0x02, 0x54, 0x4A, 0x29, 0x00, 0x02, 0x51,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// 24С01_02 // Ricoh SP330H 7K (408283) for Ricoh Ricoh SP 330
const PROGMEM char NOTE_SP_330[] = { "SP 330" }; 
const PROGMEM byte dump_ricoh_sp_330_408283[128] = {
  0x45, 0x00, 0x01, 0x04, 0x0E, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x38, 0x32, 0x38, 0x33, 0x18, 0x07, 0x52, 0x47, 0x14, 0x00, 0x32, 0x38,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP310 cyan (122700) for Ricoh Ricoh SP 310
const PROGMEM char NOTE_SP_310_C[] = { "SP 310 C" }; 
const PROGMEM byte dump_ricoh_sp_310_122700_cyan[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x32, 0x02, 0x01, 0xFF, 0x64, 0x00, 0x31, 0x32,
  0x32, 0x37, 0x30, 0x30, 0x09, 0x03, 0x41, 0x42, 0x17, 0x00, 0x17, 0x06,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP310 black (406479) for Ricoh Ricoh SP 310
const PROGMEM char NOTE_SP_310_B[] = { "SP 310 B" };
const PROGMEM byte dump_ricoh_sp_310_406479_black[128] = {
  0xA8, 0x00, 0x01, 0x03, 0x32, 0x01, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x34, 0x37, 0x39, 0x11, 0x07, 0x41, 0x42, 0x16, 0x00, 0x37, 0x80,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


// 24С01_02 // Ricoh SP310 magenta (122728) for Ricoh Ricoh SP 310
const PROGMEM char NOTE_SP_310_M[] = { "SP 310 M" };
const PROGMEM byte dump_ricoh_sp_310_122728_magenta[128] = {
0xA8, 0x00, 0x01, 0x03, 0x32, 0x03, 0x01, 0xFF, 0x64, 0x00, 0x31, 0x32,
  0x32, 0x37, 0x32, 0x38, 0x09, 0x11, 0x41, 0x42, 0x18, 0x00, 0x11, 0x32,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP310 yellow (406482) for Ricoh Ricoh SP 310
const PROGMEM char NOTE_SP_310_Y[] = { "SP 310 Y" };
const PROGMEM byte dump_ricoh_sp_310_406482_yellow[128] = {
0xA8, 0x00, 0x01, 0x03, 0x32, 0x04, 0x01, 0xFF, 0x64, 0x00, 0x34, 0x30,
  0x36, 0x34, 0x38, 0x32, 0x11, 0x07, 0x41, 0x42, 0x19, 0x00, 0x02, 0x50,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x64, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP360 cyan (408177)
const PROGMEM char NOTE_SP_360_C[] = { "SP 360 C" };
const PROGMEM byte dump_ricoh_sp_360_408177_cyan[128] = {
  0x2F, 0x00, 0x01, 0x02, 0x2A, 0x02, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x38, 0x31, 0x37, 0x37, 0x17, 0x07, 0x54, 0x4A, 0x07, 0x00, 0x25, 0x4E,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP360 magenta (408178)
const PROGMEM char NOTE_SP_360_M[] = { "SP 360 M" };
const PROGMEM byte dump_ricoh_sp_360_408178_magenta[128] = {
  0x2F, 0x00, 0x01, 0x02, 0x2D, 0x03, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x38, 0x31, 0x37, 0x38, 0x17, 0x02, 0x54, 0x4A, 0x07, 0x00, 0x26, 0x4F,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 24С01_02 // Ricoh SP360 yellow (408179)
const PROGMEM char NOTE_SP_360_Y[] = { "SP 360 Y" };
const PROGMEM byte dump_ricoh_sp_360_408179_yellow[128] = {
 0x2F, 0x00, 0x01, 0x02, 0x27, 0x04, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x38, 0x31, 0x37, 0x39, 0x17, 0x01, 0x54, 0x4A, 0x07, 0x00, 0x26, 0x46,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Ricoh SP360 black (408184)
const PROGMEM char NOTE_SP_360_B[] = { "SP 360 B" };
const PROGMEM byte DUMP_SP_360_BLACK[128] = {
  0x2F, 0x00, 0x01, 0x02, 0x41, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x38, 0x31, 0x37, 0x36, 0x17, 0x01, 0x54, 0x4A, 0x07, 0x00, 0x24, 0x53,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// Ricoh SP377 6.4K (408162) => Aficio SP 377DNwX/377SFNwX 
const PROGMEM char NOTE_SP_377[] = { "SP 377" };
const PROGMEM byte DUMP_SP_377[128] = {
  0x07, 0x02, 0x01, 0x02, 0x0D, 0x01, 0x01, 0x00, 0x64, 0x00, 0x34, 0x30,
  0x38, 0x31, 0x36, 0x31, 0x16, 0x02, 0x4D, 0x53, 0x27, 0x00, 0x07, 0x56,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
/*********** =====> SAMSUNG <===== *********/

// 24С04_16 // Samsung SCX-D4200A 3K for Samsung SCX-4200/4220 
const PROGMEM char NOTE_SCX_D4200[] = { "SCX 4200/20" }; 
const PROGMEM byte dump_samsung_scx_d4200a[512] = {
  0x43, 0x34, 0x32, 0x30, 0x30, 0x45, 0x58, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x31, 0x33, 0x30, 0x37, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x31, 0x33, 0x30, 0x37, 0x32, 0x35, 0x33, 0x32, 0x31, 0x31, 0x35, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0x34, 0x32, 0x30, 0x30, 0x45, 0x58, 0x50,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xDD, 0x00, 0x22, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,   
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

/*********** =====> XEROX <===== *********/

// 24С04_16 // Xerox 013R00625 3K for XEROX WC 3119
const PROGMEM char NOTE_WC_3119[] = { "WC 3119" };
const PROGMEM byte dump_xerox_013R00625[512] = {
  0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x30, 0x36, 0x30, 0x36, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x30, 0x36, 0x30, 0x36, 0x32, 0x39, 0x30, 0x39, 0x33, 0x31, 0x34, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xDD, 0x00, 0x22, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x43, 0x72, 0x75, 0x6D, 0x20, 0x42, 0x79, 0x20,
  0x48, 0x77, 0x61, 0x6E, 0x67, 0x2E, 0x73, 0x6B, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

// 24С04_16 // Xerox 013R00621 2K for XEROX PE 220
const PROGMEM char NOTE_PE_220[] = { "PE 220" };
const PROGMEM byte dump_xerox_013R00621[256] = {
 0x20, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x31, 0x30, 0x30, 0x32, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x31, 0x30, 0x30, 0x32, 0x30, 0x36, 0x39,
  0x38, 0x31, 0x36, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x20, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x20, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xCC, 0xDD, 0x00, 0x22, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF
};

// 24С04_16 // Xerox 006R01278 8K for Xerox WC 4118 
const PROGMEM char NOTE_WC_4118[] = { "WC 4118" };
const PROGMEM byte dump_xerox_006R01278[512] = {
  0x20, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x32, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x30, 0x38, 0x30, 0x32, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x30, 0x38, 0x30, 0x32, 0x30, 0x36, 0x31, 0x36, 0x30, 0x30, 0x31, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x32, 0x20,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x30, 0x30, 0x38, 0x30, 0x32, 0x00, 0x00,
  0x43, 0x52, 0x55, 0x4D, 0x2D, 0x30, 0x38, 0x30, 0x32, 0x30, 0x36, 0x31, 0x36, 0x30, 0x30, 0x31,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0xCF, 0x58, 0x45, 0x52, 0x4F, 0x58, 0x32,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

/*********** =====> CANON <===== *********/
// 416RT //  Canon  MC-G02 for Canon PIXMA G1420, G2420, G2460, G3420, G3460, G640 и G540
const PROGMEM char NOTE_CANON_G_SERIES[] = { "Canon G Series" };
const PROGMEM byte dump_canon_g_series[2048] = {
  0x22, 0x7B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x83, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x7B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x83, 0x2A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5A, 0x3B, 0x7F, 0x54, 0x8A, 0x03, 0x3A, 0x39, 0x33, 0x12, 0xFE, 0xC0, 0xFD, 0x71, 0x48, 0x9F,
  0x3D, 0xFD, 0x3D, 0xF6, 0xE2, 0xB9, 0xA2, 0x46, 0x43, 0x3C, 0x0C, 0xC7, 0x6B, 0x1D, 0x20, 0xA2, 0x4A, 0x31, 0x9F, 0x8B, 0xE6, 0x22, 0x31, 0xE2,
  0x54, 0xAB, 0x64, 0xA7, 0x45, 0x14, 0x51, 0x13, 0xE8, 0xA0, 0xEA, 0x0F, 0x37, 0xF1, 0x9F, 0xDB, 0x1F, 0x82, 0x03, 0x6B, 0x6C, 0xDF, 0x96, 0x85,
  0x75, 0xDA, 0x7C, 0xD1, 0x32, 0x56, 0xCA, 0xC9, 0xA2, 0x82, 0x1F, 0xCA, 0xF8, 0x98, 0xE7, 0x07, 0x41, 0x98, 0xF8, 0xAD, 0x4F, 0x6B, 0x43, 0x81,
  0x84, 0xAC, 0x78, 0x24, 0x84, 0x56, 0x89, 0xE1, 0xB8, 0xBE, 0xDC, 0xD2, 0x7A, 0x05, 0x3F, 0xC6, 0x1C, 0xF9, 0x1B, 0xCB, 0x8F, 0x21, 0x05, 0xF1,
  0xB0, 0xCC, 0xFA, 0xEE, 0x80, 0x3A, 0xC0, 0x9C, 0x6E, 0x48, 0x02, 0xF2, 0x8A, 0xE2, 0x4E, 0x96, 0xF7, 0xAE, 0xD1, 0x29, 0xC1, 0xB8, 0x72, 0xF5,
  0x66, 0xEF, 0xD9, 0xC1, 0x7F, 0xF5, 0x3E, 0x64, 0x03, 0x05, 0xB6, 0xB3, 0x32, 0xDC, 0x4E, 0xF5, 0x4C, 0x1A, 0xA5, 0x21, 0xA7, 0xCF, 0xAD, 0x90,
  0x29, 0x9A, 0x16, 0xF1, 0x72, 0x2F, 0x9E, 0x21, 0xEF, 0xE3, 0x4D, 0xE7, 0x00, 0x6B, 0x82, 0xE3, 0x2E, 0xC0, 0x38, 0x64, 0x72, 0xC7, 0x77, 0xC5,
  0x1B, 0xEA, 0x83, 0xCC, 0x14, 0x67, 0xD8, 0x94, 0x9D, 0x9F, 0x53, 0x82, 0x4F, 0xD2, 0x54, 0x19, 0x84, 0xF3, 0xEC, 0x98, 0x72, 0x9C, 0x27, 0x83,
  0x3F, 0x6D, 0x3B, 0xA4, 0x15, 0xD6, 0x0A, 0x8B, 0x72, 0xE2, 0x0B, 0x85, 0x88, 0xF8, 0x3F, 0xE5, 0xCE, 0xE6, 0xEF, 0x16, 0xC0, 0xE2, 0x48, 0x42,
  0xC9, 0x4C, 0x0C, 0xD2, 0xC3, 0xBA, 0x27, 0xFF, 0x8F, 0x08, 0x23, 0x3E, 0xD2, 0xA8, 0x28, 0xA8, 0xEB, 0x91, 0x8A, 0x5E, 0x43, 0xFA, 0x3A, 0xD1,
  0xFF, 0xEE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5A, 0x3B, 0x7F, 0x54, 0x8A, 0x03, 0x3A, 0x39,
  0x33, 0x12, 0xFE, 0xC0, 0xFD, 0x71, 0x48, 0x9F, 0x3D, 0xFD, 0x3D, 0xF6, 0xE2, 0xB9, 0xA2, 0x46, 0x43, 0x3C, 0x0C, 0xC7, 0x6B, 0x1D, 0x20, 0xA2,
  0x4A, 0x31, 0x9F, 0x8B, 0xE6, 0x22, 0x31, 0xE2, 0x54, 0xAB, 0x64, 0xA7, 0x45, 0x14, 0x51, 0x13, 0xE8, 0xA0, 0xEA, 0x0F, 0x37, 0xF1, 0x9F, 0xDB,
  0x1F, 0x82, 0x03, 0x6B, 0x6C, 0xDF, 0x96, 0x85, 0x75, 0xDA, 0x7C, 0xD1, 0x32, 0x56, 0xCA, 0xC9, 0xA2, 0x82, 0x1F, 0xCA, 0xF8, 0x98, 0xE7, 0x07,
  0x41, 0x98, 0xF8, 0xAD, 0x4F, 0x6B, 0x43, 0x81, 0x84, 0xAC, 0x78, 0x24, 0x84, 0x56, 0x89, 0xE1, 0xB8, 0xBE, 0xDC, 0xD2, 0x7A, 0x05, 0x3F, 0xC6,
  0x1C, 0xF9, 0x1B, 0xCB, 0x8F, 0x21, 0x05, 0xF1, 0xB0, 0xCC, 0xFA, 0xEE, 0x80, 0x3A, 0xC0, 0x9C, 0x6E, 0x48, 0x02, 0xF2, 0x8A, 0xE2, 0x4E, 0x96,
  0xF7, 0xAE, 0xD1, 0x29, 0xC1, 0xB8, 0x72, 0xF5, 0x66, 0xEF, 0xD9, 0xC1, 0x7F, 0xF5, 0x3E, 0x64, 0x03, 0x05, 0xB6, 0xB3, 0x32, 0xDC, 0x4E, 0xF5,
  0x4C, 0x1A, 0xA5, 0x21, 0xA7, 0xCF, 0xAD, 0x90, 0x29, 0x9A, 0x16, 0xF1, 0x72, 0x2F, 0x9E, 0x21, 0xEF, 0xE3, 0x4D, 0xE7, 0x00, 0x6B, 0x82, 0xE3,
  0x2E, 0xC0, 0x38, 0x64, 0x72, 0xC7, 0x77, 0xC5, 0x1B, 0xEA, 0x83, 0xCC, 0x14, 0x67, 0xD8, 0x94, 0x9D, 0x9F, 0x53, 0x82, 0x4F, 0xD2, 0x54, 0x19,
  0x84, 0xF3, 0xEC, 0x98, 0x72, 0x9C, 0x27, 0x83, 0x3F, 0x6D, 0x3B, 0xA4, 0x15, 0xD6, 0x0A, 0x8B, 0x72, 0xE2, 0x0B, 0x85, 0x88, 0xF8, 0x3F, 0xE5,
  0xCE, 0xE6, 0xEF, 0x16, 0xC0, 0xE2, 0x48, 0x42, 0xC9, 0x4C, 0x0C, 0xD2, 0xC3, 0xBA, 0x27, 0xFF, 0x8F, 0x08, 0x23, 0x3E, 0xD2, 0xA8, 0x28, 0xA8,
  0xEB, 0x91, 0x8A, 0x5E, 0x43, 0xFA, 0x3A, 0xD1, 0xFF, 0xEE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x5B, 0x17, 0x82, 0x71, 0xDA, 0x80, 0x53, 0x24, 0x14, 0x90, 0x91, 0x15, 0x3D, 0xA8, 0x71, 0xC1, 0x9B, 0xBD, 0x94, 0x4A, 0xAF, 0xF7, 0x82, 0x55,
  0xB0, 0x99, 0x39, 0x2D, 0x95, 0xC2, 0x09, 0xBC, 0xD5, 0x18, 0xC4, 0xE6, 0x8F, 0xEE, 0xF4, 0xD1, 0x0E, 0x51, 0x99, 0x6D, 0x82, 0x43, 0xB9, 0x9A,
  0xFD, 0xE3, 0x61, 0xBD, 0x12, 0xB8, 0x6E, 0x34, 0x09, 0xD6, 0xF2, 0x51, 0x01, 0x76, 0x4B, 0xE4, 0x57, 0x5C, 0x3D, 0x50, 0xF4, 0x28, 0xA5, 0x6F,
  0xB1, 0x60, 0x88, 0x4A, 0x2C, 0x25, 0x7E, 0x12, 0x55, 0xFA, 0x81, 0x22, 0x6C, 0x69, 0xDF, 0x7F, 0x01, 0xC6, 0x12, 0x09, 0x00, 0x0C, 0x46, 0xBE,
  0xE7, 0x5E, 0x53, 0xB3, 0xBA, 0x3A, 0xFE, 0x99, 0xBD, 0x2C, 0x79, 0x6C, 0x52, 0x0B, 0x5E, 0xA0, 0xD2, 0x05, 0x3D, 0xC5, 0x99, 0x50, 0x55, 0xC7,
  0x2D, 0x17, 0x37, 0x77, 0x33, 0x0F, 0xBE, 0x75, 0xD3, 0x83, 0x16, 0x7C, 0x26, 0x22, 0xED, 0xA3, 0x96, 0xDD, 0x48, 0x4F, 0x85, 0x72, 0xB1, 0xC2,
  0xB7, 0xD9, 0x1D, 0x04, 0x20, 0xEF, 0x14, 0x62, 0x97, 0xB5, 0xB2, 0x87, 0xE1, 0x41, 0x9D, 0x92, 0x8A, 0x10, 0xC7, 0xE8, 0x15, 0x50, 0xEA, 0x95,
  0x19, 0xAF, 0x1C, 0x96, 0x50, 0xDE, 0x73, 0x8C, 0x34, 0xAB, 0xE5, 0xCF, 0x66, 0x2C, 0xF7, 0x3D, 0x5C, 0xC7, 0xA8, 0xED, 0x70, 0x0B, 0xF7, 0x62,
  0x1E, 0xD6, 0x94, 0xDC, 0x6A, 0x03, 0x06, 0x8B, 0xD9, 0x06, 0x8E, 0x18, 0xF2, 0x52, 0x05, 0xF5, 0x82, 0xBF, 0xE1, 0x6A, 0x57, 0x3B, 0xD0, 0xF2,
  0x03, 0x28, 0x67, 0xE5, 0xF3, 0xB8, 0x07, 0x0C, 0x3E, 0xEE, 0xEB, 0x4C, 0x6D, 0x7A, 0x07, 0x9C, 0x2C, 0x3D, 0xC2, 0x9A, 0x82, 0xC6, 0x85, 0xA6,
  0xC8, 0x65, 0xA6, 0x2C, 0x52, 0xDD, 0xED, 0xDD, 0xBD, 0x2F, 0x47, 0xC6, 0x26, 0x78, 0xF3, 0xCE, 0x0A, 0x5B, 0xC4, 0xA6, 0xF0, 0x8D, 0x2E, 0x47,
  0x60, 0x8B, 0xDB, 0xD6, 0xDA, 0x87, 0x01, 0xCA, 0x11, 0x46, 0xF9, 0xB0, 0xC7, 0xD2, 0x35, 0xA0, 0xC5, 0xAE, 0xD0, 0x38, 0x8E, 0x6B, 0xF5, 0xB3,
  0xF0, 0xE3, 0x0D, 0xDB, 0x5E, 0x22, 0x5E, 0x74, 0x3A, 0x7E, 0xE9, 0xCF, 0xCC, 0x36, 0x88, 0xF2, 0x13, 0x83, 0x05, 0x84, 0x57, 0xBF, 0x5A, 0xC0,
  0x6F, 0x3E, 0x46, 0x79, 0x4F, 0x32, 0x94, 0x2C, 0x5B, 0x52, 0x1D, 0x2F, 0x2A, 0x79, 0xAC, 0x82, 0x8E, 0x6E, 0xBC, 0x97, 0x87, 0xD0, 0x0C, 0x1C,
  0x2F, 0x46, 0xA2, 0x37, 0xE8, 0xCC, 0xCD, 0xCE, 0x8A, 0x33, 0xF2, 0x7A, 0xB2, 0x3A, 0xB1, 0x47, 0x74, 0xE9, 0xB1, 0x7F, 0xAE, 0xC3, 0x7B, 0x7A,
  0xED, 0x19, 0xAD, 0xA7, 0x5F, 0x6F, 0xDB, 0x3D, 0x78, 0xA6, 0x44, 0x37, 0x25, 0x85, 0x76, 0x4A, 0x49, 0x6A, 0x08, 0xE3, 0x7D, 0x7D, 0x80, 0x2F,
  0xF6, 0x5F, 0x7C, 0x90, 0x00, 0xB2, 0x52, 0xBC, 0xC9, 0x21, 0xFA, 0x3F, 0xEE, 0x9E, 0x68, 0xD9, 0x76, 0x1A, 0x73, 0xDB, 0xEB, 0x03, 0xA4, 0x31,
  0xD1, 0x62, 0x4D, 0xF4, 0xBA, 0x52, 0x5B, 0xB2, 0x43, 0xF0, 0xA8, 0xD9, 0x91, 0xE5, 0xD6, 0x5C, 0x1D, 0xA5, 0x3C, 0x35, 0x9D, 0x4B, 0xCB, 0x59,
  0x4B, 0xCD, 0x41, 0x59, 0x26, 0x7F, 0x1C, 0x15, 0xB4, 0x94, 0xE5, 0xA8, 0x6B, 0x3D, 0xBA, 0xE3, 0xBD, 0x68, 0x31, 0x58, 0x12, 0x59, 0x4B, 0x6D,
  0xFB, 0x5C, 0x0B, 0xEE, 0xA0, 0xD6, 0x48, 0xA0, 0x1C, 0xEA, 0xD1, 0x67, 0x7E, 0x0D, 0x55, 0xEA, 0x5D, 0x3B, 0x40, 0x02, 0x35, 0x75, 0xF6, 0x42,
  0x05, 0xBD, 0x4B, 0xD9, 0x9F, 0x31, 0x7A, 0xB4, 0x9D, 0xA2, 0xDB, 0x11, 0xC5, 0x37, 0x42, 0x55, 0x4F, 0x9E, 0xCA, 0x56, 0xCB, 0x07, 0xE6, 0x58,
  0x6E, 0x37, 0xB1, 0x5C, 0x1C, 0xD4, 0x32, 0x4F, 0xA9, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5B, 0x17, 0x82, 0x71, 0xDA, 0x80, 0x53, 0x24,
  0x14, 0x90, 0x91, 0x15, 0x3D, 0xA8, 0x71, 0xC1, 0x9B, 0xBD, 0x94, 0x4A, 0xAF, 0xF7, 0x82, 0x55, 0xB0, 0x99, 0x39, 0x2D, 0x95, 0xC2, 0x09, 0xBC,
  0xD5, 0x18, 0xC4, 0xE6, 0x8F, 0xEE, 0xF4, 0xD1, 0x0E, 0x51, 0x99, 0x6D, 0x82, 0x43, 0xB9, 0x9A, 0xFD, 0xE3, 0x61, 0xBD, 0x12, 0xB8, 0x6E, 0x34,
  0x09, 0xD6, 0xF2, 0x51, 0x01, 0x76, 0x4B, 0xE4, 0x57, 0x5C, 0x3D, 0x50, 0xF4, 0x28, 0xA5, 0x6F, 0xB1, 0x60, 0x88, 0x4A, 0x2C, 0x25, 0x7E, 0x12,
  0x55, 0xFA, 0x81, 0x22, 0x6C, 0x69, 0xDF, 0x7F, 0x01, 0xC6, 0x12, 0x09, 0x00, 0x0C, 0x46, 0xBE, 0xE7, 0x5E, 0x53, 0xB3, 0xBA, 0x3A, 0xFE, 0x99,
  0xBD, 0x2C, 0x79, 0x6C, 0x52, 0x0B, 0x5E, 0xA0, 0xD2, 0x05, 0x3D, 0xC5, 0x99, 0x50, 0x55, 0xC7, 0x2D, 0x17, 0x37, 0x77, 0x33, 0x0F, 0xBE, 0x75,
  0xD3, 0x83, 0x16, 0x7C, 0x26, 0x22, 0xED, 0xA3, 0x96, 0xDD, 0x48, 0x4F, 0x85, 0x72, 0xB1, 0xC2, 0xB7, 0xD9, 0x1D, 0x04, 0x20, 0xEF, 0x14, 0x62,
  0x97, 0xB5, 0xB2, 0x87, 0xE1, 0x41, 0x9D, 0x92, 0x8A, 0x10, 0xC7, 0xE8, 0x15, 0x50, 0xEA, 0x95, 0x19, 0xAF, 0x1C, 0x96, 0x50, 0xDE, 0x73, 0x8C,
  0x34, 0xAB, 0xE5, 0xCF, 0x66, 0x2C, 0xF7, 0x3D, 0x5C, 0xC7, 0xA8, 0xED, 0x70, 0x0B, 0xF7, 0x62, 0x1E, 0xD6, 0x94, 0xDC, 0x6A, 0x03, 0x06, 0x8B,
  0xD9, 0x06, 0x8E, 0x18, 0xF2, 0x52, 0x05, 0xF5, 0x82, 0xBF, 0xE1, 0x6A, 0x57, 0x3B, 0xD0, 0xF2, 0x03, 0x28, 0x67, 0xE5, 0xF3, 0xB8, 0x07, 0x0C,
  0x3E, 0xEE, 0xEB, 0x4C, 0x6D, 0x7A, 0x07, 0x9C, 0x2C, 0x3D, 0xC2, 0x9A, 0x82, 0xC6, 0x85, 0xA6, 0xC8, 0x65, 0xA6, 0x2C, 0x52, 0xDD, 0xED, 0xDD,
  0xBD, 0x2F, 0x47, 0xC6, 0x26, 0x78, 0xF3, 0xCE, 0x0A, 0x5B, 0xC4, 0xA6, 0xF0, 0x8D, 0x2E, 0x47, 0x60, 0x8B, 0xDB, 0xD6, 0xDA, 0x87, 0x01, 0xCA,
  0x11, 0x46, 0xF9, 0xB0, 0xC7, 0xD2, 0x35, 0xA0, 0xC5, 0xAE, 0xD0, 0x38, 0x8E, 0x6B, 0xF5, 0xB3, 0xF0, 0xE3, 0x0D, 0xDB, 0x5E, 0x22, 0x5E, 0x74,
  0x3A, 0x7E, 0xE9, 0xCF, 0xCC, 0x36, 0x88, 0xF2, 0x13, 0x83, 0x05, 0x84, 0x57, 0xBF, 0x5A, 0xC0, 0x6F, 0x3E, 0x46, 0x79, 0x4F, 0x32, 0x94, 0x2C,
  0x5B, 0x52, 0x1D, 0x2F, 0x2A, 0x79, 0xAC, 0x82, 0x8E, 0x6E, 0xBC, 0x97, 0x87, 0xD0, 0x0C, 0x1C, 0x2F, 0x46, 0xA2, 0x37, 0xE8, 0xCC, 0xCD, 0xCE,
  0x8A, 0x33, 0xF2, 0x7A, 0xB2, 0x3A, 0xB1, 0x47, 0x74, 0xE9, 0xB1, 0x7F, 0xAE, 0xC3, 0x7B, 0x7A, 0xED, 0x19, 0xAD, 0xA7, 0x5F, 0x6F, 0xDB, 0x3D,
  0x78, 0xA6, 0x44, 0x37, 0x25, 0x85, 0x76, 0x4A, 0x49, 0x6A, 0x08, 0xE3, 0x7D, 0x7D, 0x80, 0x2F, 0xF6, 0x5F, 0x7C, 0x90, 0x00, 0xB2, 0x52, 0xBC,
  0xC9, 0x21, 0xFA, 0x3F, 0xEE, 0x9E, 0x68, 0xD9, 0x76, 0x1A, 0x73, 0xDB, 0xEB, 0x03, 0xA4, 0x31, 0xD1, 0x62, 0x4D, 0xF4, 0xBA, 0x52, 0x5B, 0xB2,
  0x43, 0xF0, 0xA8, 0xD9, 0x91, 0xE5, 0xD6, 0x5C, 0x1D, 0xA5, 0x3C, 0x35, 0x9D, 0x4B, 0xCB, 0x59, 0x4B, 0xCD, 0x41, 0x59, 0x26, 0x7F, 0x1C, 0x15,
  0xB4, 0x94, 0xE5, 0xA8, 0x6B, 0x3D, 0xBA, 0xE3, 0xBD, 0x68, 0x31, 0x58, 0x12, 0x59, 0x4B, 0x6D, 0xFB, 0x5C, 0x0B, 0xEE, 0xA0, 0xD6, 0x48, 0xA0,
  0x1C, 0xEA, 0xD1, 0x67, 0x7E, 0x0D, 0x55, 0xEA, 0x5D, 0x3B, 0x40, 0x02, 0x35, 0x75, 0xF6, 0x42, 0x05, 0xBD, 0x4B, 0xD9, 0x9F, 0x31, 0x7A, 0xB4,
  0x9D, 0xA2, 0xDB, 0x11, 0xC5, 0x37, 0x42, 0x55, 0x4F, 0x9E, 0xCA, 0x56, 0xCB, 0x07, 0xE6, 0x58, 0x6E, 0x37, 0xB1, 0x5C, 0x1C, 0xD4, 0x32, 0x4F,
  0xA9, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };

/*********** =====> KATUSHA <===== *********/
// HT24L02 //  Katusha KT240 for Katusha M240 CHIP 9k TK-240X
const PROGMEM char NOTE_KATUSHA_TK240X[] = { "TK 240" };
const PROGMEM byte dump_katusha_tk240x[256] = {
  0x00, 0x00, 0x30, 0x39, 0x00, 0xD9, 0x41, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23, 0x28,
  0x00, 0x00, 0x00, 0x00, 0x54, 0x4B, 0x32, 0x34, 0x30, 0x58, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x54, 0x33, 0x37, 0x33, 0x31, 0x32, 0x30, 0x35, 0x32, 0x32, 0x38, 0x37, 
  0x30, 0x36, 0x39, 0x30, 0x35, 0x39, 0x31, 0x31, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x4B, 0x41, 0x54, 0x55, 0x53, 0x48, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x41, 0x56, 0x4B, 0x2D, 0x30, 0x34, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// HT24L02 //  Katusha KT240 for Katusha M240
const PROGMEM char NOTE_KATUSHA_DR240[] = { "DR 240" };
const PROGMEM byte dump_katusha_dr240[256] = {
  0x00, 0x00, 0x30, 0x39, 0x00, 0x00, 0x75, 0x30, 0x00, 0x00, 0x00, 0x00,
  0x44, 0x52, 0x32, 0x34, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x45, 0x33, 0x42, 0x30,
  0x33, 0x34, 0x37, 0x34, 0x31, 0x32, 0x37, 0x42, 0x31, 0x30, 0x39, 0x33,
  0x35, 0x31, 0x31, 0x36, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x4B, 0x41, 0x54, 0x55, 0x53, 0x48, 0x41, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x02, 0x93, 0x2E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x4D, 0x41, 0x34, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70,
  0x00, 0x00, 0x00, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFF, 0xFF, 0xFF
};

// HT24L02 //  Katusha KT240 for Katusha M240 CHIP 6k TK-240A
const PROGMEM char NOTE_KATUSHA_TK240A[] = { "TK 240" };
const PROGMEM byte dump_katusha_tk240a[256] = {
	0x00, 0x00, 0x30, 0x39, 0x00, 0x90, 0xD6, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x17, 0x70, 0x00, 0x00, 0x00, 0x00, 0x54, 0x4B, 0x32, 0x34,
	0x30, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x54, 0x33, 0x42, 0x31, 0x38, 0x38, 0x33, 0x35,
	0x37, 0x32, 0x38, 0x38, 0x42, 0x31, 0x31, 0x30, 0x30, 0x33, 0x31, 0x36,
	0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x4B, 0x41, 0x54, 0x55, 0x53, 0x48, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x56, 0x4B, 0x2D,
	0x30, 0x34, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00
};

/** НАЧАЛО **/
// Подключаем библиотеку которая позволяет взаимодействовать с различными устройствами по интерфейсу I2C / TWI.
#include <I2C.h>

// Подключаем библиотеку которая позволяет управлять микросхемами 24CXX подключать их на ПИН A4 (SDA), A5 (SCL)
#include <Eeprom24C01_16.h> // Библиотека работает с 24C01 24C02 24C04 24C08 24C16

// Библиотека которая позволяет перевести в спящий режим ардуино
#include <avr/sleep.h>

// Библиотека которая позволяет работать с внутренней памятью Arduino
#include <EEPROM.h>
  
// Подключаем библиотеку которая позволяет управлять различными жидкокристаллическими дисплеями (LCD)
#include <LiquidCrystal.h>  
// Подключаем библиотеку для записи статических строк во FLASH а не в RAM 
// Serial.print(F(Тут_статическая_строка)) или const PROGMEM до вызова SETUP
// Serial.println(pgm_read_byte(&dump_ricoh_sp_150[i]), HEX); чтение переменной без изменений из FLASH
#include <avr/pgmspace.h>

// Пины LCD 1602 (RS, E, D4, D5, D6, D7)
LiquidCrystal lcd( 8, 9, 4, 5, 6, 7 );

// Пин питания у Вас может быть другой
#define POWER_PIN A2
// Пин для работы генератора случайных чисел
#define RANDOM_PIN A3
//
// #define BUTTON_RESET __attribute__((section(".noinit")))


// Адрес чипа (адрес динамический, меняется от чипа к чипу)
byte global_address_eeprom;

// Номер чипа по умолчанию
byte global_id = 0;

// Кол-во чипов в базе данных
int global_all_chip_in_database;

// Имя дампа
const byte* global_name_dump;

// Размер чипа
int global_size_dump = 0;

// Номер функции которая помняет серийник 0 -- замена не нужна
int global_change_crum = 0;

// Состояние кнопки (защита от повторного срабатывания)
boolean global_button_press = false; // true - кнопка нажата

// Время отсчета для кнопки SELECT
unsigned long time_passed = 0; 

// Запоминаем количество нажатий на кнопку на кнопку select
int global_button_select = 0; 

// Переменные для кнопок
int BUTTON_UP;
int BUTTON_DOWN;
int BUTTON_RIGHT;
int BUTTON_LEFT;
int BUTTON_SELECT;

// Переменная для отслеживания кнопки BUTTON_RESET, при включении питания BUTTON_RESET = 0
byte BUTTON_RESET __attribute__((section(".noinit")));

// Кнопка была нажата или нет
boolean BUTTON_BUSY = false;

// Храним время последнео нажатия любой кнопки кроме reset
unsigned long global_timer_to_sleep = 0;

// ** DEFINE ** //
// => BRAND
const PROGMEM char BRAND_RICOH[] = { "RICOH" };
const PROGMEM char BRAND_SAMSUNG[] = { "SAMSUNG" };
const PROGMEM char BRAND_XEROX[] = { "XEROX" };
const PROGMEM char BRAND_CANON[] = { "CANON" };
const PROGMEM char BRAND_KATUSHA[] = { "KATUSHA" };
// => PINOUT
const PROGMEM char PINOUT_GVCD[] = { "GVCD" };
const PROGMEM char PINOUT_GVDC[] = { "GVDC" };
const PROGMEM char PINOUT_VDCG[] = { "VDCG" };
const PROGMEM char PINOUT_GCDV[] = { "GCDV" };
const PROGMEM char PINOUT_GDCV[] = { "GDCV" };

// => PAGE
const PROGMEM char PAGE_1_5_K[] = { "1.5K" };
const PROGMEM char PAGE_2_K[] = { "2K" };
const PROGMEM char PAGE_2_6_K[] = { "2.6K" };
const PROGMEM char PAGE_3_K[] = { "3K" };
const PROGMEM char PAGE_3_5_K[] = { "3.5K" };
const PROGMEM char PAGE_5_K[] = { "5K" };
const PROGMEM char PAGE_6_K[] = { "6K" };
const PROGMEM char PAGE_6_4_K[] = { "6.4K" };
const PROGMEM char PAGE_6_5_K[] = { "6.5K" };
const PROGMEM char PAGE_7_K[] = { "7K" };
const PROGMEM char PAGE_8_K[] = { "8K" };
const PROGMEM char PAGE_9_K[] = { "9K" };
const PROGMEM char PAGE_12_K[] = { "12K" };
const PROGMEM char PAGE_30_K[] = { "30K" };
// => CHIP_MEMORY
const PROGMEM int CHIP_MEMORY_128 = 128;
const PROGMEM int CHIP_MEMORY_256 = 256;
const PROGMEM int CHIP_MEMORY_512 = 512;
const PROGMEM int CHIP_MEMORY_1024 = 1024;
const PROGMEM int CHIP_MEMORY_2048 = 2048;

/** Создаем структуру базы данных (проще говоря многомерный массив с разными данными) **/
struct Struct_DB
{
  const char* brand;
  const char* page;
  const char* pinout;
  const char* note;
  const byte* dump;
  const int chip_memory;
  const int change_crum;
};

/** База Данных **/
Struct_DB datebase[] = {
  // Brand, Page, Pinuot, Note, Dump, Size, Crum
  // Crum 0 = Ни чего не делать ; 1 = Генерация 1 серийника Samsung|Xerox ; 2 - Генерация 2х серийников Samsung|Xerox; 3 - Генерация 1 серийника Ricoh  

  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVCD, NOTE_SP_100, dump_ricoh_sp_101e_407059, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_6_K, PINOUT_GVCD, NOTE_SP_111, dump_ricoh_sp_110e_407441, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_1_5_K, PINOUT_GVCD, NOTE_SP_150, dump_ricoh_sp_150_408010, CHIP_MEMORY_128 , 0 },  
  { BRAND_RICOH,    PAGE_2_6_K, PINOUT_GVCD, NOTE_SP_200_202_203_210_212, dump_ricoh_sp_200_hl_407262, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_6_K, PINOUT_GVCD, NOTE_SP_201_204_211_213_220, dump_ricoh_sp_201_hl_111135,CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C220_B, dump_ricoh_sp_c220_221_222_240_406144_black, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C220_C, dump_ricoh_sp_c220_221_222_240_406145_cyan, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C220_M, dump_ricoh_sp_c220_221_222_240_406146_magenta, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C220_Y, dump_ricoh_sp_c220_221_222_240_406147_yellow, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C250_260_B, dump_ricoh_sp_c250_c260_407543_black, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C250_260_M, dump_ricoh_sp_c250_c260_407545_magenta, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C250_260_Y, dump_ricoh_sp_c250_c260_407546_yellow, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_K,   PINOUT_GVDC, NOTE_SP_C250_260_C, dump_ricoh_sp_c250_c260_407544_cyan, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_5_K, PINOUT_GVDC, NOTE_SP_C252_B, dump_ricoh_sp_c252_407716_black, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_C252_C, dump_ricoh_sp_c252_407717_cyan, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_C252_M, dump_ricoh_sp_c252_407718_magenta, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_C252_Y, dump_ricoh_sp_c252_407719_yellow, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_2_6_K, PINOUT_GVCD, NOTE_SP_277, dump_ricoh_sp_277_408160, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_1_5_K, PINOUT_GVDC, NOTE_SP_300, dump_ricoh_sp_300_406956, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_310_B, dump_ricoh_sp_310_406479_black, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_310_Y, dump_ricoh_sp_310_406482_yellow, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_310_M, dump_ricoh_sp_310_122728_magenta, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVDC, NOTE_SP_310_C, dump_ricoh_sp_310_122700_cyan, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_3_5_K, PINOUT_GVCD, NOTE_SP_311_325_NORMAL, dump_ricoh_sp_311_407246, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_4_K, PINOUT_GVCD, NOTE_SP_311_325_LARGE, dump_ricoh_sp_311_821242, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_7_K,   PINOUT_GVCD, NOTE_SP_330, dump_ricoh_sp_330_408283, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_4_K, PINOUT_GVCD, NOTE_SP_377, DUMP_SP_377, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_5_K,   PINOUT_GVCD, NOTE_SP_400_450, dump_ricoh_sp_400_450, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_5_K,   PINOUT_GVDC, NOTE_SP_3400_3410_3500_3510, dump_ricoh_sp_3400he_406522, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_6_4_K, PINOUT_GVDC, NOTE_SP_3500_3510, dump_ricoh_sp_3500xe_406990, CHIP_MEMORY_128 , 0 },  
  { BRAND_RICOH,    PAGE_12_K,  PINOUT_GVCD, NOTE_SP_3600_3610_4510, dump_ricoh_sp_4500he_407318, CHIP_MEMORY_128, 3 },      // 3 функция с 23 начало
  { BRAND_RICOH,    PAGE_6_K,   PINOUT_GVCD, NOTE_SP_3600_3610_4510, dump_ricoh_sp_4500e_407340, CHIP_MEMORY_128, 3 },       // 3 функция с 23 начало  
  { BRAND_SAMSUNG,  PAGE_3_K,   PINOUT_VDCG, NOTE_SCX_D4200, dump_samsung_scx_d4200a, CHIP_MEMORY_512 , 1 },                 // 1 функция с 63 начало
  { BRAND_XEROX,    PAGE_2_K,   PINOUT_VDCG, NOTE_PE_220, dump_xerox_013R00621, CHIP_MEMORY_512, 1 },                        // 1 функция с 63 начало
  { BRAND_XEROX,    PAGE_3_K,   PINOUT_VDCG, NOTE_WC_3119, dump_xerox_013R00625, CHIP_MEMORY_512 , 1 },                      // 1 функция с 63 начало
  { BRAND_XEROX,    PAGE_8_K,   PINOUT_GCDV, NOTE_WC_4118, dump_xerox_006R01278, CHIP_MEMORY_512 , 2 },                      // 2 функция с 63 начало и 191
  { BRAND_RICOH,    PAGE_5_K,   PINOUT_GVDC, NOTE_SP_360_Y, dump_ricoh_sp_360_408179_yellow, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_5_K,   PINOUT_GVDC, NOTE_SP_360_M, dump_ricoh_sp_360_408178_magenta, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_5_K,   PINOUT_GVDC, NOTE_SP_360_C, dump_ricoh_sp_360_408177_cyan, CHIP_MEMORY_128 , 0 },
  { BRAND_RICOH,    PAGE_5_K,   PINOUT_GVDC, NOTE_SP_360_B, DUMP_SP_360_BLACK, CHIP_MEMORY_128 , 0 },         
  { BRAND_CANON,    PAGE_5_K,   PINOUT_GDCV, NOTE_CANON_G_SERIES, dump_canon_g_series, CHIP_MEMORY_2048 , 0 },  
  { BRAND_KATUSHA,  PAGE_6_K,   PINOUT_GVDC, NOTE_KATUSHA_TK240A, dump_katusha_tk240a, CHIP_MEMORY_256 , 4 },               // 4 функция
  { BRAND_KATUSHA,  PAGE_9_K,   PINOUT_GVDC, NOTE_KATUSHA_TK240X, dump_katusha_tk240x, CHIP_MEMORY_256 , 4 },               // 4 функция  
  { BRAND_KATUSHA,  PAGE_30_K,  PINOUT_GVDC, NOTE_KATUSHA_DR240, dump_katusha_dr240, CHIP_MEMORY_256 , 5 }                  // 5 функция

  // Последняя строка без запятой !!!
  // { "", "", "", NOTE, sizeof(), 0 }, // шаблон 
};

// Вывод на LCD информацию по чипу и установка глобальных переменных
void set_global_variables(int row)
{
  // Показываем на LCD brand, page, pinout, note
  lcd.clear();
  lcd.setCursor(0,0);
  for(byte i1=0; i1 < strlen_P(datebase[row].brand); i1++){ lcd.print((char)pgm_read_byte(&datebase[row].brand[i1])); }   
  lcd.print(" ");
  for(byte i2=0; i2 < strlen_P(datebase[row].page); i2++){ lcd.print((char)pgm_read_byte(&datebase[row].page[i2])); }  
  lcd.setCursor(12,0);
  for(byte i3=0; i3 < strlen_P(datebase[row].pinout); i3++){ lcd.print((char)pgm_read_byte(&datebase[row].pinout[i3])); }  
  lcd.setCursor(0,1);  
  for(byte i4=0; i4 < strlen_P(datebase[row].note); i4++){ lcd.print((char)pgm_read_byte(&datebase[row].note[i4])); }
  
  // Устанавливаем глобальные переменные dump chip_memory change_crum
  global_name_dump = datebase[row].dump;
  global_size_dump = datebase[row].chip_memory; 
  global_change_crum = datebase[row].change_crum;
}

/****************************** SETUP ******************************/

void setup() 
{   
  //pinMode(10,OUTPUT);

  lcd.begin(16, 2);  // Инициализируем LCD 16x2
  Serial.begin(9600); //инициализируем последовательное соединение для работы с ПК
  while (!Serial) { ; } // Ждем когда подключится ардуино к пк по usb

  //Wire.begin(); //инициализируем библиотеку I2C / TWI для работы с I2C устройствами
  
  //инициализируем библиотеку I2C / TWI для работы с I2C устройствами
  I2c.begin();
  I2c.timeOut(5);
  I2c.pullup(true);

  // Пин А2 для питания чипа устанавливаем в положение OUTPUT
  // Пин A0-14 A1-15 A2-16 A3-17 A4-18 A5-19
  pinMode(POWER_PIN, OUTPUT);
  
  // Пин А3 для работы генератора случайных чисел
  randomSeed(analogRead(RANDOM_PIN));

  // Подсчитываем сколько чипов в Базе 
  global_all_chip_in_database = ( sizeof(datebase) / sizeof(Struct_DB) ) - 1 ; 
  //Serial.print("Rows in DB => "); Serial.println( global_all_chip_in_database );  

  // Очистка EEPROM
  // clear_value_button();
  
  // Проверка если значения кнопока в памяти есть то считываем их иначе просим их ввести
  if ( purity_eeprom_check() == true ) { write_value_button(); } else { read_value_button(); } 

  // Устанавливаем глобальные переменные и показываем первый чип на экране
  set_global_variables(global_id);

  // Запуск калибровки кнопок если нажали reset 5 раз  
  calibration_button_via_button_reset();
}


/****************************** LOOP ******************************/

void loop() 
{  
  /* ОБРАБОТКА НАЖАТИЯ КНОПОК */

  switch ( button(BUTTON_RIGHT) )
  {
    case 0:
      break;
    case 1: 
      //Serial.println(F("BUTTON_RIGHT SHORT")); 
      if (global_id != global_all_chip_in_database)
      {
        // Увеличиваем счетчик и показываем на экране следующий чип
        global_id++;
        set_global_variables(global_id);
      }
      else
      {
        // Показываем на экране 1 чип
        global_id = 0;
        set_global_variables(global_id);
      }
      break;
    case 2:
      //Serial.println(F("BUTTON_RIGHT LONG")); 
      break;
  }

  switch ( button(BUTTON_LEFT) )
  {
    case 0:
      break;
    case 1: 
      //Serial.println(F("BUTTON_LEFT SHORT")); 
      if (global_id != 0)
      {
        // Уменьшаем счетчик и показываем предыдущий чип
        global_id--; 
        set_global_variables(global_id);
      }
      else
      {
        // Показываем на экране последний чип в базе данных
        global_id = global_all_chip_in_database; 
        set_global_variables(global_id);
      }
      break;
    case 2:
      //Serial.println(F("BUTTON_LEFT LONG")); 
      break;
  }

  switch ( button(BUTTON_UP) )
  {
    case 0:
      break;
    case 1: 
      //Serial.println(F("BUTTON_UP SHORT")); 
      // Подаем питание на чип
      power_on_for_chip();
      
      //сканируем шину i2c на наличие чипа, если все хорошо
      if (search_address_chip_3()) 
      {
        // Скоростная прошивка чипа  
        firmware();             
      }
            
      // Выключаем питание
      power_off_for_chip();

      // Возврат в меню
      set_global_variables(global_id);
      break;
    case 2:
      //Serial.println(F("BUTTON_UP LONG")); 
      break;
  }

  switch ( button(BUTTON_DOWN) )
  {
    case 0:
      break;
    case 1: 
      //Serial.println(F("BUTTON_DOWN SHORT")); 
      // Подаем питание на чип
      power_on_for_chip();

      //сканируем шину i2c на наличие чипа
      if (search_address_chip_3()) 
      { 
        // Считываем чип и показываем его на lcd
        read_chip_and_display_it();  
        
        // Чтение дампа и вывод его в порт монитора
        //extract_dump(global_size_dump);    
       }
      
      // Выключаем питание
      power_off_for_chip();

      // Возврат в меню
      set_global_variables(global_id);
      break;
    case 2:
      //Serial.println(F("BUTTON_DOWN LONG")); 
      break;
  }

  switch ( button(BUTTON_SELECT) )
  {
    case 0:
      break;
    case 1: 
      //Serial.println(F("BUTTON_SELECT SHORT"));

      // Увеличиваем счетчик или сбрасываем на 1 
      global_button_select = global_button_select + 1;
      
      // Если закончились программы то сбрасываем на 1
      if ( global_button_select > 7 ) // 7 это кол-во подпрограмм
      {
        global_button_select = 1;
      }

      // Показываем подпрограмму
      switch(global_button_select)
      {
        case 0:
            break;
        case 1:
          lcd.clear();
          lcd.print(F("Calibration"));
          lcd.setCursor(0,1);
          lcd.print(F("keypad shield"));               
          break;
        case 2:
          lcd.clear();
          lcd.print(F("See total pages")); 
          lcd.setCursor(0,1);
          lcd.print(F("Only SP 111/150"));               
          break;
        case 3:
          lcd.clear();
          lcd.print(F("Firmware chip"));
          lcd.setCursor(0,1);
          lcd.print(F("With timer"));
          break;
        case 4:
          lcd.clear();
          lcd.print(F("Read dump no PC"));
          lcd.setCursor(0,1);
          lcd.print(F("128 bytes"));             
          break;
        case 5:
          lcd.clear();
          lcd.print(F("Read dump no PC"));
          lcd.setCursor(0,1);
          lcd.print(F("256 bytes"));
          break;
        case 6:
          lcd.clear();
          lcd.print(F("Read dump no PC"));
          lcd.setCursor(0,1);
          lcd.print(F("512 bytes"));
          break;
        case 7:
          lcd.clear();
          lcd.print(F("Read dump on PC"));
          lcd.setCursor(0,1);
          lcd.print(F("2048 bytes"));
          break;

      }
      
      break;
    case 2:
      //Serial.println(F("BUTTON_SELECT LONG")); 
      // Долгое зажатие приводит к выполнению подпрограммы
     switch(global_button_select)
     {
      case 0:
        break;
      case 1:
        calibration_button(); // Калибровка кнопок
        break;
      case 2:
        total_pages_on_display_ricoh(); // Показываем на дисплей количество страниц из чипа (только для Ricoh)
        break;
      case 3:
        firmware_chip_with_timer(5); // В скобках сколько секунд ждать перед пршивкой   
        break;
      case 4:
        extract_dump(128);  // Показываем в мониторе порта дамп с чипа первые 128 байт      
        break;
      case 5:
        extract_dump(256);  // Показываем в мониторе порта дамп с чипа первые 256 байт       
        break; 
      case 6:
        extract_dump(512);   // Показываем в мониторе порта дамп с чипа первые 512 байт         
        break;
      case 7:
        extract_dump(2048);   // Показываем в мониторе порта дамп с чипа первые 2048 байт         
        break;  
      } 
      // Сбрасываем меню SELECT
      global_button_select = 0;
      break;
  }

  // Переводим в спящий режим ардуино
  time_to_sleep();
}

/****************************** ЗАПИСЬ-ЧТЕНИЕ-ОБНУЛЕНИЕ-КАЛИБРОВКА В EEPROM КНОПОК LCD KEYPAD SHIELD ******************************/

// Запуск калибровки кнопок через кнопку RESET
void calibration_button_via_button_reset()
{
  // Если значение кнопки RESET больше 5 то обнуляем переменную, иначе увеличиваем счетчик
  if (BUTTON_RESET > 5) { BUTTON_RESET = 0; } else { ++BUTTON_RESET; }
  // Если RESET нажали 5 раз то запускаем перекалибровку кнопок и обуляем счетчик RESET 
  if (BUTTON_RESET == 5) { Serial.println(F("START CALIBRATION BUTTON")); calibration_button(); BUTTON_RESET = 0; }
  Serial.print(F("BUTTON_RESET COUNT => ")); Serial.println(BUTTON_RESET);
}

// Считываем из EEPROM
void read_value_button()
{
  for(int i = 0; i < 5; i++)
  {
    int value;
    if ( i == 0 ) { BUTTON_UP = word( EEPROM.read(0), EEPROM.read(1) ); Serial.print(F("UP => ")); Serial.println(BUTTON_UP); };
    if ( i == 1 ) { BUTTON_DOWN = word( EEPROM.read(2), EEPROM.read(3) ); Serial.print(F("DOWN => ")); Serial.println(BUTTON_DOWN); };
    if ( i == 2 ) { BUTTON_RIGHT = word( EEPROM.read(4), EEPROM.read(5) ); Serial.print(F("RIGHT => ")); Serial.println(BUTTON_RIGHT); };
    if ( i == 3 ) { BUTTON_LEFT = word( EEPROM.read(6), EEPROM.read(7) ); Serial.print(F("LEFT => ")); Serial.println(BUTTON_LEFT); };
    if ( i == 4 ) { BUTTON_SELECT = word( EEPROM.read(8), EEPROM.read(9) ); Serial.print(F("SELECT => ")); Serial.println(BUTTON_SELECT); };
  }
}

// записываем в EEPROM
void write_value_button()
{
  for (int i = 0; i < 5; i++)
  {
    lcd.clear();
    lcd.print(F("HOLD DOWN"));
    lcd.setCursor(0,1);
    //
    switch(i)
    {
      case 0:
        lcd.print(F("BUTTON UP"));
        break;
      case 1:
        lcd.print(F("BUTTON DOWN"));
        break;
      case 2:
        lcd.print(F("BUTTON RIGHT"));
        break;
      case 3:
        lcd.print(F("BUTTON LEFT"));
        break;
      case 4:
        lcd.print(F("BUTTON SELECT"));
        break;
    } 
    // Считываем значение каждой кнопки 5 раз
    for(int k = 0; k < 5; k++)
    {
      delay(1000);
      int value = analogRead(0); // Считываем значение кнопки
      byte hi = highByte(value); // Запоминаем старший байт
      byte low = lowByte(value); // Запоминаем младший байт
      if ( i == 0 ) { EEPROM.write(0, hi); EEPROM.write(1, low); };
      if ( i == 1 ) { EEPROM.write(2, hi); EEPROM.write(3, low); };
      if ( i == 2 ) { EEPROM.write(4, hi); EEPROM.write(5, low); };
      if ( i == 3 ) { EEPROM.write(6, hi); EEPROM.write(7, low); };
      if ( i == 4 ) { EEPROM.write(8, hi); EEPROM.write(9, low); };      
      Serial.println(value);
    }
    //
    lcd.clear();
    lcd.setCursor(0,0);
    lcd.print(F("PUSH OUT BUTTON"));
    delay(3000);

    // обнуляем счетчик сна
    reset_time_to_sleep();
  }
}

// Очищаем EEPROM
void clear_value_button()
{
  for (int i = 0 ; i < EEPROM.length() ; i++) 
  {
    EEPROM.write(i, 255);
  }
}

// Проверка EEPROM на чистоту -- true eeprom чистая
bool purity_eeprom_check()
{
  if ( 
    word( EEPROM.read(0), EEPROM.read(1) ) == 65535 || 
    word( EEPROM.read(2), EEPROM.read(3) ) == 65535 || 
    word( EEPROM.read(4), EEPROM.read(5) ) == 65535 ||
    word( EEPROM.read(6), EEPROM.read(7) ) == 65535 || 
    word( EEPROM.read(8), EEPROM.read(9) ) == 65535
    ) { return true; } else { return false; }   
}

// Калибровка кнопок
void calibration_button()
{
   // Очищаем EEPROM
   clear_value_button();
   // Запускаем ввод значений
   write_value_button();
   // Говорим что нужно перезапустить arduino
   lcd.clear();
   lcd.print(F("PRESS BUTTON"));
   lcd.setCursor(0,1);
   lcd.print(F("RESET"));
}
/****************************** ЗАЩИТА ОТ ДРЕБЕЗГА КНОПОК И ПРОВЕКА СОСТОЯНИЯ КНОПКИ ******************************/
// Возвращаем true - кнопка нажата   false - не нажата

bool button_on_off(int RESISTOR_BUTTON)
{
  // Параметры резистора с допусками +-20
  int RESISTOR_BUTTON_MIN = RESISTOR_BUTTON - 20;
  int RESISTOR_BUTTON_MAX = RESISTOR_BUTTON + 20; 

   // Сопротивление кнопки которую нажали
  int RESISTOR_NOW = analogRead(0); 
  if ( RESISTOR_NOW > RESISTOR_BUTTON_MIN && RESISTOR_NOW < RESISTOR_BUTTON_MAX ) 
  {
    // Защита от дребезга кнопки
    delay(50);
    RESISTOR_NOW = analogRead(0); 
    if ( RESISTOR_NOW > RESISTOR_BUTTON_MIN && RESISTOR_NOW < RESISTOR_BUTTON_MAX ) 
    {   
      // Если нажали любую кнопку то обнуляем счетчик сна
      reset_time_to_sleep();
      // Кнопка нажата
      return true;
    }
    else
    {
      // Был дребезг кнопки
      return false; 
    }
  }
  else
  {
    // Кнопка отпущена
    return false;
  }
}

/****************************** ПРОВЕРКА НА КОРОТКОЕ ИЛИ ДОЛГОЕ НАЖАТИЕ НА КНОПКУ ******************************/
// Возвращаем 1 - SHORT click   2 - LONG click
int button(int RESISTOR_BUTTON)
{  
    
  if ( button_on_off(RESISTOR_BUTTON) == true ) 
  {  
    // Запускаем таймер
    unsigned long time_push_button = millis();
    // Время срабатывание Long click
    int time_delay = 2000;

    while ( (millis() - time_push_button) < time_delay )
    {
      // Если кнопку отпустили и до этого не нажимали 
      if( button_on_off(RESISTOR_BUTTON) == false &&  BUTTON_BUSY == false)
      {
        //Serial.println("RETURN 1");  
        return 1;
      }
      // Если кнопку отпустили и до этого нажимали
      else if( button_on_off(RESISTOR_BUTTON) == false &&  BUTTON_BUSY == true )
      { 
        //Serial.println("RETURN 0"); 
        BUTTON_BUSY = false; 
        return 0;
      }
    } 
    // Если кнопку не отпускали больше времени в переменной time_delay, значит это Long click
    //Serial.println("RETURN 2");
    BUTTON_BUSY = true;
    return 2;
  }
  else { return 0; }

}

/****************************** ПРОВЕРКА ЗНАЧЕНИЙ КНОПОК ******************************/
void print_sensor_value(String name_button)
{
  Serial.println(F(""));
  Serial.print(F("Значение выдаваемое кнопкой "));
  Serial.print(name_button);
  Serial.print(F(":"));
  Serial.println(analogRead(0)); // Проверка кнопок, какие они выдают значения.
}


/****************************** ВКЛЮЧАЕМ ПИТАНИЯ ЧИПА ******************************/

void power_on_for_chip()
{
  digitalWrite(POWER_PIN, HIGH); // Подаем питания на A2 для запитки чипа
  delay(500); // Задержка для поднятия напряжения
}

/****************************** ВЫКЛЮЧАЕМ ПИТАНИЯ ЧИПА ******************************/
void power_off_for_chip()
{
  digitalWrite(POWER_PIN, LOW); // Выключаем питания на A2 пине
}

/****************************** ПОИСК ЧИПА НА ШИНЕ I2C ВЕРСИЯ 3 МОДИФИКАЦИЯ 2024-04-17 ******************************/
// Возваращаем 1 если все ок и 0 если все плохо
bool search_address_chip_3() 
{
    byte DeviceStatus;
    byte TotalDevicesFound = 0;
    //Serial.println(F("Scanning for devices...please wait")); Serial.println();

    // Сканируем шину I2C
    for (byte address = 0; address <= 0x7F; address++)
    {
      DeviceStatus = 0;
      // I2c._start() возвращает 0 если все хорошо, 1 если превышено время ожидания шины, 2 и более другие ошибки
      DeviceStatus = I2c._start();
      if (!DeviceStatus)
      {
        // I2c._sendAddress возвращает 0 если все хорошо, 1 если првышено время ожидания шины, 2 и более другие ошибки.
        // SLA_W Узнаем можем ли писать в микросхему
        DeviceStatus = I2c._sendAddress(SLA_W(address));
      }
      if (DeviceStatus)
      {
        if (DeviceStatus == 1)
        {
          lcd.clear(); 
          lcd.print(F("MAYBE PROBLEM"));  
          lcd.setCursor(0,1); 
          lcd.print(F("WITH BUS I2C"));
          Serial.println(F("MAYBE PROBLEM WITH BUS I2C")); 
          delay (2000);
          return false;
        }
      }
      else
      { 
        //Serial.print(F("Found device at address - 0x")); Serial.println(address, HEX);
        // Ищем первый адрес с подходящими параметрами, их может быть больше одного а нам нужен лишь первый
        if (TotalDevicesFound == 0)
        {
          // Сохраняем адрес чипа в памяти
          global_address_eeprom = address;
          //
          //Serial.print(F("Save address device - 0x")); Serial.println(address, HEX); 
        }
        // Считаем количество подходящих адресов
        TotalDevicesFound++;
      }
      // Отпускаем шину
      I2c._stop();
    }

    // Если устройст не найдено
    if (!TotalDevicesFound)
    {
      lcd.clear(); 
      lcd.print(F("BAD CONTACT OR"));  
      lcd.setCursor(0,1); 
      lcd.print(F("NOT CHIP"));
      Serial.println(F("BAD CONTACT OR NOT CHIP")); 
      delay (2000);
      return false;
    }
  /*
    byte error;
    byte count_device = 0;
    // Сканируем шину I2C
    for (byte address = 0; address <= 127; address++)
    {
       // Переменная для ошибок 0 по умолчанию
       error = 0; 
       // I2c._start() возвращает 0 если все хорошо, 1 если првышено время ожидания шины, 2 и более другие ошибки
       error = I2c._start();
       //I2c.scan();
       // ... 
       if ( error == 0 ) 
        {           
          // I2c._sendAddress возвращает 0 если все хорошо, 1 если првышено время ожидания шины, 2 и более другие ошибки.
          // В конце адреса надо указывать бит чтения << 1 или записи << 0
          error = I2c._sendAddress(address << 1);
          Serial.print("Adress 0x"); Serial.println(address, HEX);
          // Если ошибок нет и нашли адрес то ...
          if ( error == 0)
          {
              // Берем адреес шины и пытаемся считать данные с чипа по умолчанию
              Eeprom24C01_16 eeprom(address);
              // Инициализируем библиотеку eeprom
              eeprom.initialize();
              
              // Ищем первый адрес с подходящими параметрами, их может быть больше 1 нам нужен лишь 1  
              if (eeprom.readByte_24C04_16(0) != 0 && count_device == 0) 
              //if (eeprom.readByte_24C01_02(0) != 0 && count_device == 0)              
              {        
                global_address_eeprom = address; // Сохраняем адрес чипа в памяти
                Serial.print(F("Address chip = 0x")); Serial.println(address);  // Показываем адрес на котором сидит чип
                // Считаем сколько нашли чипов
                count_device = count_device + 1;
              }         
           }
         }
        
       // Отпускаем шину с адресом, I2c._stop() возвращает 0 если все хорошо, 1 если првышено время ожидания шины, 2 и более другие ошибки
       I2c._stop();
    }
    

    // Сообщаем либо плохой контакт или чипа нет либо все хорошо
    if(count_device == 0)
    {
      lcd.clear(); 
      lcd.print(F("BAD CONTACT OR"));  
      lcd.setCursor(0,1); 
      lcd.print(F("NOT CHIP"));
      Serial.print(F("BAD CONTACT OR NOT CHIP")); 
      delay (2000);
      return false; 
    }
    else
    {         
      return true;  
    }
    */
}

/****************************** СКОРОСТНАЯ ПРОШИВКА ЧИПОВ УНИВЕРСАЛЬНАЯ БИБЛИОТЕКА ******************************/
void firmware()
{
  lcd.clear();
  lcd.print(F("FIRMWARE CHIP")); 
  lcd.setCursor(0, 1);      
  lcd.blink(); // влючаем мигание курсора для информативности
 
  // Подключаем библиотеку и задем адрес и размер чипа
  Eeprom24C01_16 eeprom(global_address_eeprom); 
  eeprom.initialize(); 

  // Занимаемый размер массива в оперативке 2 4 8 16 32 64 128 байт
  // Максимум 128 байт т.к. оперативку надо экономить
  byte sizeArray = 64;  
  // количество циклов
  byte cycl = global_size_dump / sizeArray; 
  // старт цикла
  for (byte x = 0; x < cycl; x++)
  {      
      // создаем пустой массив байт
      byte array_bytes[sizeArray];  
      // Из памяти ардуино считываем часть дампа в массив
      for (byte y = 0; y < sizeArray; y++)
      {
          word numByte = y + (x * sizeArray);
          array_bytes[y] = pgm_read_byte(&global_name_dump[numByte]);     
      }      
      // Записываем массив в чип
      if ( (global_size_dump == 128) || (global_size_dump == 256) ) { eeprom.writeBytes_24C01_02(sizeArray * x, sizeArray, array_bytes); }
      if ( (global_size_dump == 512) || (global_size_dump > 512) )  { eeprom.writeBytes_24C04_16(sizeArray * x, sizeArray, array_bytes); }    
      // Пауза для записи ячейки памяти
      delay(10);           

      // Показываем массив
      // Serial.print(F("String => ")); Serial.print(x); Serial.print(F(" "));
      // for (byte i = 0; i < sizeArray; i++)
      // {
      //     Serial.print(array_bytes[i], HEX);
      //     Serial.print(F(" "));
      // }
      // Serial.println(F(" "));

      //Чистим массив
      //array_bytes[0] = '\0';
  }

  // Медленная прошивка (прошивает по байтно) работает всегда но долго
  // for (int x = 0; x < global_size_dump; x++)
  // {
  //   eeprom.writeByte_24C04_16(x, pgm_read_byte(&global_name_dump[x]) ); 
  //   // Пауза для записи ячейки памяти
  //   delay(10);  
  // }

  // Сообщение о прошивки чипа 
  lcd.print(F("DONE !!!"));
  lcd.noBlink(); // отключаем мигание курсора
  Serial.println(F("FIRMWARE GOOD"));
  
  // Проверка чипа
  verification_dump();

  //Смена серийного номера
  change_crum_select(); 

  


}
 

/************************************* ПРОВЕРКА ДАМПА ПОСЛЕ ПРОШИВКИ *************************************/
void verification_dump()
{
  lcd.clear();
  lcd.print(F("VERIFICATION")); 
  lcd.setCursor(0,1);
  Serial.print(F("VERIFICATION "));
    
  Eeprom24C01_16 eeprom(global_address_eeprom);
  eeprom.initialize();  

  //Serial.print("global_address_eeprom = ");
  //Serial.println(global_address_eeprom, HEX);
  
  // Кол-во ошибок
  byte error = 0;
  for(int i = 0; i < global_size_dump; i++) // Циклы
  {
    //Serial.print(global_size_dump);
    if(pgm_read_byte(&global_name_dump[i]) != eeprom.readByte_24C04_16(i))
    {
      error = error + 1;
      /*
      Serial.println(F("")); 
      Serial.print(F("BYTE = "));
      Serial.print(i);
      Serial.print(F(" PROGMEM = "));
      Serial.print(pgm_read_byte(&global_name_dump[i]), HEX);
      Serial.print(F(" EEPROM = "));
      Serial.println(eeprom.readByte_24C04_16(i), HEX); 
      */   
    }
    
    //Serial.print(F("number byte = "));
    //Serial.print(i);
    //Serial.print(F(" PROGMEM = "));
    //Serial.print(pgm_read_byte(&global_name_dump[i]), HEX);
    //Serial.print(F(" EEPROM = "));
    //Serial.println(eeprom.readByte(i), HEX);
  }

  // Если ошибок нет то GOOD иначе ERROR
  if ( error == 0 ) 
  { 
    lcd.print(F("GOOD")); 
    Serial.println(F("GOOD")); 
    delay(1000); 
  } 
  else 
  { 
    lcd.print(F("ERROR")); 
    Serial.println(F("ERROR"));
    delay(2000);
  }
}

/*************************************  ГЕНЕРАТОР СЕРИЙНОГО НОМЕРА МОДИФИКАЦИЯ 2024-05-17  *************************************/
// Выбор какая функция смены серийного номера заработает
void change_crum_select()
{  
  switch (global_change_crum)
  {
    case 0:
      break;
    case 1: 
      // SAMSUNG XEROX где 1 серийник 
      // Меняем байты серийника и показываем его
      change_crum_universal(56, 63); // меняем с 56 байта по 63 байт
      print_sn_on_lcd_universal(53, 63);
      break;
    case 2:
      // SAMSUNG XEROX где 2 серийника
      change_crum_two_xerox();
      break;
    case 3:
      // RICOH SP_3600_3610_4510 
      // Меняем байты серийника и показываем его
      change_crum_universal(22, 23); // меняем с 22 байта по 23 байт
      print_sn_on_lcd_universal(22, 23);
      break;
    case 4:
      // KATUSHA TK 240 
      // Меняем байты серийника и показываем его
      change_crum_universal(60, 73); // меняем с 60 байта по 73 байт
      print_sn_on_lcd_universal(60, 73);
      break;
    case 5:
      // KATUSHA DR 240 
      // Меняем байты серийника и показываем его
      change_crum_universal(52, 65); // меняем с 42 байта по 65 байт   
      print_sn_on_lcd_universal(52, 65);
      break;
    default:
      break;
  }
}

// Генератор crum иниверсальный
// указывается с какого байда и по какой байт поменять цифры
void change_crum_universal(int From, int To)
{
  // Инициализация eeprom 
  Eeprom24C01_16 eeprom(global_address_eeprom);
  eeprom.initialize();  
  // Меняем байты от (FROM) и до (TO)
  for (int i = From; i <= To; i++)
  {   
   int randomNum = random(48, 57); // ANSI (48-58) а в DEC (0-9)
   eeprom.writeByte_24C04_16(i, randomNum); // Записываем значение в адрес
   delay(10); // пауза для записи в ячейку EEPROM 
  }
}


// Генератора для Samsung или Xerox где надо сменить 2 номерa 
// Младший разряд находится в 63 байте и в 191
// ...
void change_crum_two_xerox()
{  
  Eeprom24C01_16 eeprom(global_address_eeprom);
  eeprom.initialize();
  
  int temp_sn_one = 63;
  int temp_sn_two = 191;
  for (int i = 6; i > 0; i--) //  меняем 6 младших разрядов серийника
  {
    int randomNum = random(48, 57); // ANSI (48-58) а в DEC (0-9)
    eeprom.writeByte_24C04_16(temp_sn_one, randomNum); // Записываем значение в адрес
    delay(10); // пауза для записи в ячейку EEPROM
    eeprom.writeByte_24C04_16(temp_sn_two, randomNum); // Записываем значение в адрес
    delay(10); // пауза для записи в ячейку EEPROM
    temp_sn_one--; // переход к старшему разряду
    temp_sn_two--; // переход к старшему разряду
  }
  
  // Показываем серийный номер на lcd
  print_sn_on_lcd_universal(53, 63);
  //
  Serial.println(F("CHANGE TWO CRUM GOOD"));
}

  
/************************************* ВЫВОД СЕРИЙНОГО НОМЕРА НА LCD *************************************/
// Показать CRUM от (FROM) байта до (TO) байта
void print_sn_on_lcd_universal(int From, int To) 
{  
  // Инициализация
  Eeprom24C01_16 eeprom(global_address_eeprom);
  eeprom.initialize(); 
  // Показываем на дисплее надпись NEW CRUM 
  lcd.clear();
  lcd.print(F("NEW CRUM")); Serial.print(F("NEW CRUM "));
  lcd.setCursor(0,1); 
  // Считываем байты от и до
  for(int i = From; i <= To; i++)  
  {
    char c = (char)eeprom.readByte_24C04_16(i); // получаем ascii из hex 
    lcd.print(c); Serial.print(c);
  }
  Serial.println(" ");  
  // Задержка для просмотра номера
  delay(1500);
  // Сообщаем что все ок
  Serial.println(F("CHANGE CRUM GOOD")); 
}

/************************************* ПОКАЗ ДАМПА НА LCD *************************************/

void read_chip_and_display_it()
{
  Eeprom24C01_16 eeprom(global_address_eeprom);
  eeprom.initialize(); 

  //char c = (char)eeprom.readByte_24C04_16(0); // получил hex to ascii
  int byte_in_str = 16;
  //int sizeof_chip = 256;  // Показываем 16 строк
  //int sizeof_chip = 128;  // Показываем 8 строк
  //int sizeof_chip = 96; // Показываем 6 строк
  int sizeof_chip = global_size_dump;
  int num_str_in_chip = sizeof_chip / byte_in_str;

  for(int i_1 = 0; i_1 < num_str_in_chip; i_1++)
  {
      lcd.clear();
      lcd.print(F("STRING # "));
      lcd.print(i_1);
      for (int i_2 = 0; i_2 < 17; i_2++)
      {
        lcd.setCursor(i_2,1);
        char a = (char)eeprom.readByte_24C04_16(i_2 + i_1 * byte_in_str); // Получаем ascii
        char b; // 
        if (a < 32){ b = 32; } // если a 0 то ставим пробел HEX(32)
        else{ b = a; }
        lcd.print(b); // 15 31 47 63 79 95 111 127
        //lcd.setCursor(i_2,0);
        //Serial.println(eeprom.readByte_24C04_16(i_2 + i_1 * byte_in_str));
      }
      delay(500);
  }
  
  //lcd.clear();
  /*
  for (int i=0; i < 128; i++)
  {
    char a = (char)eeprom.readByte(i); // Получаем ascii
    char b; // 
    if (a < 32){ b = 32; } // если a 0 то ставим пробел HEX(32)
    else{ b = a; }
    //lcd.print(b); // 15 31 47 63 79 95 111 127
    //lcd.setCursor(i,0);
    Serial.println(eeprom.readByte(i));
  }
   */
}

/************************************* ПОКАЗ ДАМПА В МОНИТОРЕ ПОРТА *************************************/
void extract_dump(int sizeof_chip)
{ 
  lcd.clear();
  lcd.print("READ DUMP ON PC");
  // Подаем питание на чип
  power_on_for_chip();
  
  //сканируем шину i2c на наличие чипа, если есть ошибка перепрыгиваем на error_i2c_scan
  if (search_address_chip_3())
  {
      Eeprom24C01_16 eeprom(global_address_eeprom);
      eeprom.initialize();
      
      //int sizeof_chip = capacity_chip;  // Количество байт в чипе
      int num_str_in_chip = sizeof_chip / 16; // Количство строк в чипе

      // Столбики и строки для красоты =)
      //Serial.println(F(""));
      //Serial.println(F("   | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0E 0D 0F"));
      //Serial.println(F("- - - - - - - - - - - - - - - - - - - - - - - - - - "));
      //const char* column[] = { "00", "10", "20", "30", "40", "50", "60", "70", "80", "90", "0A", "0B", "0C", "0D", "0E", "0F" };
      
      for (int count_str = 0; count_str < num_str_in_chip;  count_str++)
      {
        //Serial.print( column[count_str] );
        //Serial.print(" | ");
        
        for (int i = 0; i < 16 ; i++)
        {  
          unsigned char letter = (unsigned char)eeprom.readByte_24C04_16(i + count_str * 16); // Получаем байт из чипа
          if (letter < 16){ Serial.print(F("0")); } // Если это число меньше 16 то добавляем 0 спереди
          Serial.print(letter, HEX); 
          Serial.print(F(" "));
        }
        Serial.println(F("")); // Переход на новую строку
      } 
  }
  
  // Включаем питание
  power_off_for_chip();

  // Возврат в меню
  set_global_variables(global_id);
}

/************************************* ПРОШИВКА ЧИПА С ТАЙМЕРОМ *************************************/
void firmware_chip_with_timer(int timer)
{
  // Таймер обратного отсчета
  countdown_timer(timer);
      
  // Подаем питание на чип
  power_on_for_chip();
  
  //сканируем шину i2c на наличие чипа, если есть ошибка перепрыгиваем на error_i2c_scan
  if (search_address_chip_3())
  {
     //Скоростная прошивка чипа
    firmware();
  }
  
  // Выключаем питание
  power_off_for_chip();

  // Возврат в меню
  set_global_variables(global_id);
}

/************************************* ТАЙМЕР ОБРАТНОГО ОТСЧЕТА *************************************/
void countdown_timer(int timer)
{
  //int timer = 8; // Время которое ждем перед прошивкой чипа
  lcd.clear(); 
  lcd.print(F("COUNTDOWN TIMER"));
  for(int i = timer; i > 0; i--)
  {
    lcd.setCursor(0,1);
    lcd.print(i); 
    delay(1000); // Задержка в 1 сек перед повтором цикла
  }
}

/************************************* ПОКАЗ ОТПЕЧАТАННЫХ СТРАНИЦ ДЛЯ RICOH *************************************/
void total_pages_on_display_ricoh()
{
  // Подаем питание на чип
  power_on_for_chip();
  
  //сканируем шину i2c на наличие чипа
  if (search_address_chip_3()) 
  {
    Eeprom24C01_16 eeprom(global_address_eeprom);
    eeprom.initialize(); 
  
    lcd.clear();
    lcd.print(F("TOTAL PAGE"));
    lcd.setCursor(0,1);
      
    byte HigherByte = eeprom.readByte_24C01_02(65); // Считываем 65 байт это старшый разряд
    byte LowerByte = eeprom.readByte_24C01_02(64); // Считываем 64 байт это младший разряд
    int Result = (HigherByte << 8) | LowerByte; // соединяем 2 разряда в одно
    
    lcd.print(Result); // показываем число на экран
    
    delay(5000); // 5 секунд  
  }
  
  // Выключаем питание
  power_off_for_chip();

  // Возврат в меню
  set_global_variables(global_id);
}

/************************************* ОТПРАВЛЯЕМ В СОН АРДУИНО *************************************/
void time_to_sleep()
{
  // Не забудьте выпаять светодиоды для экономии батарейки
  // Время до сна 240 сек = 4 мин
  unsigned long timer = 240000;
  // Секундомер
  unsigned long stopwatch = millis() - global_timer_to_sleep; 
  //Serial.println(stopwatch);
  if ( stopwatch > timer)
    {
      //Serial.println("SLEEP");
      //Отключаем дисплей
      lcd.noDisplay();  delay(500);
      //Отключаем подсветку
      pinMode(10,OUTPUT);
      // Запрещаем просыпаться от всего кроме как по кнопке reset 
      noInterrupts();
      // Включаем глубой сон
      set_sleep_mode(SLEEP_MODE_PWR_DOWN);
      sleep_mode();  
    }
   //Serial.println("NO SLEEP");
}

// обнуление счетчика сна запихнул в функцию bool button_on_off(int RESISTOR_BUTTON)
void reset_time_to_sleep()
{
  global_timer_to_sleep = millis();
}

/************************************* ОТЛАДКА *************************************/

/************************************* Узнаем сколько во время работы осталось RAM (не используется) ******************************/
/*
//Использование
//Serial.println(memoryFree());

// Переменные, создаваемые процессом сборки,
// когда компилируется скетч
extern int __bss_end;
extern void *__brkval;
 
// Функция, возвращающая количество свободного ОЗУ (RAM)
int memoryFree()
{
   int freeValue;
   if((int)__brkval == 0)
      freeValue = ((int)&freeValue) - ((int)&__bss_end);
   else
      freeValue = ((int)&freeValue) - ((int)__brkval);
   return freeValue;
}

*/
